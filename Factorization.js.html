<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: Factorization.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Conversion.html">Conversion</a></div><div class="sidebar-section-children"><a href="module-Factorization.html">Factorization</a></div><div class="sidebar-section-children"><a href="module-PrimeMath.html">PrimeMath</a></div><div class="sidebar-section-children"><a href="module-UniversalNumber.html">UniversalNumber</a></div><div class="sidebar-section-children"><a href="module-Utils.html">Utils</a></div><div class="sidebar-section-children"><a href="module-config.html">config</a></div><div class="sidebar-section-children"><a href="module-dynamicLoader.html">dynamicLoader</a></div><div class="sidebar-section-children"><a href="module-math-js.html">math-js</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-UniversalNumber-UniversalNumber.html">UniversalNumber</a></div><div class="sidebar-section-children"><a href="module-Utils-PrimeMathError.html">PrimeMathError</a></div><div class="sidebar-section-children"><a href="module-Utils-PrimeMathError.html">PrimeMathError</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-namespaces"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-PrimeMath-PrimeMath.html">PrimeMath</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">Factorization.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * Factorization module for the UOR Math-JS library
 * Contains algorithms for converting integers into their prime factorization (universal coordinates)
 * Enhanced with Prime Framework optimizations for performance and efficiency
 * @module Factorization
 */

const { 
  PrimeMathError, 
  toBigInt, 
  isPrime, 
  gcd, 
  primeCache, 
  fastExp
} = require('./Utils')

// Import central configuration system
const { config } = require('./config')

/**
 * Helper function to safely extract error message
 * Non-recursive implementation to avoid stack overflows
 * 
 * @param {unknown} error - Any error value
 * @returns {string} The error message
 */
function getErrorMessage(error) {
  if (error instanceof Error) {
    // Handle errors with circular references safely
    try {
      return error.message
    } catch (e) {
      return 'Error: Could not extract message'
    }
  } else {
    // Convert non-Error objects safely
    try {
      return String(error)
    } catch (e) {
      return 'Unknown error'
    }
  }
}

/**
 * @typedef {Object} PrimeFactor
 * @property {BigInt} prime - The prime number
 * @property {BigInt} exponent - The exponent (power) of the prime
 */

/**
 * @typedef {Object} FactorizationResult
 * @property {Map&lt;BigInt, BigInt>} factors - Map of prime factors where key is the prime and value is the exponent
 * @property {boolean} isComplete - Indicates if the factorization is complete (true) or partial (false)
 * @property {number} [confidence] - Confidence level for primality testing (0-1)
 */

/**
 * @typedef {Object} WorkerConfig
 * @property {number} [threadCount] - Number of worker threads to use
 * @property {boolean} [enableWorkStealing] - Whether to enable work stealing
 * @property {number} [chunkSize] - Size of work chunks for distribution
 */

/**
 * Enhanced factorization cache optimized for the Prime Framework
 * Provides efficient caching of computed universal coordinates (prime factorizations)
 * Implements the Prime Framework's coherence and canonical representation requirements
 * @private
 */
const _factorizationCache = {
  /**
   * Get maximum size of the cache before pruning from global config
   */
  get MAX_CACHE_SIZE() {
    return config.cache.maxFactorizationCacheSize
  },
  
  /**
   * Check if persistent caching is enabled
   */
  get PERSISTENT_CACHE_ENABLED() {
    return config.cache.persistentCache
  },
  
  /**
   * Get the persistent storage key
   */
  get STORAGE_KEY() {
    return 'math-js-factorization-cache'
  },
  
  /**
   * Map storing factorization results
   * key: number as string, value: FactorizationResult
   */
  cache: new Map(),
  
  /**
   * Tracks cache usage statistics
   */
  stats: {
    hits: 0,
    misses: 0,
    total: 0,
    lastPruneTime: Date.now()
  },
  
  /**
   * Weight metrics for each entry
   * Used to determine which entries to keep during pruning
   * Factors in recency of use, computational cost, and frequency
   * key: number as string, value: {lastAccess, accessCount, computationCost}
   */
  metrics: new Map(),
  
  /**
   * Initialize the cache, possibly loading from persistent storage
   */
  initialize() {
    // If persistence is enabled, attempt to load from storage
    if (this.PERSISTENT_CACHE_ENABLED) {
      this.loadFromStorage()
    }
  },
  
  /**
   * Set the maximum cache size
   * @param {number} size - New maximum cache size
   * @throws {PrimeMathError} If size parameter is invalid
   */
  setMaxSize(size) {
    if (typeof size !== 'number' || size &lt;= 0 || !Number.isFinite(size)) {
      throw new PrimeMathError('Cache size must be a positive finite number', {
        cause: { provided: size, expected: 'positive number' }
      })
    }
    
    // Update the configuration system instead of directly setting the property
    const { configure } = require('./config')
    configure({
      cache: {
        maxFactorizationCacheSize: size
      }
    })
    
    // Prune if needed
    if (this.cache.size > this.MAX_CACHE_SIZE) {
      this.prune()
    }
  },
  
  /**
   * Get a cached factorization
   * Implements the Prime Framework's coherence inner product by ensuring
   * each access returns the canonical form of the factorization
   * 
   * @param {BigInt} num - The number to look up
   * @returns {FactorizationResult|null} The cached factorization or null if not found
   */
  get(num) {
    this.stats.total++
    
    const key = num.toString()
    const result = this.cache.get(key)
    
    if (result) {
      // Update metrics for this entry
      const metrics = this.metrics.get(key) || { accessCount: 0, computationCost: 1, lastAccess: 0 }
      metrics.accessCount++
      metrics.lastAccess = Date.now()
      this.metrics.set(key, metrics)
      
      // Record hit
      this.stats.hits++
      
      // Return a deep copy to prevent modification of cached data
      // This aligns with the Prime Framework's immutability principle
      return {
        factors: new Map(result.factors),
        isComplete: result.isComplete,
        confidence: result.confidence
      }
    }
    
    // Record miss
    this.stats.misses++
    return null
  },
  
  /**
   * Store a factorization in the cache
   * Enforces the Prime Framework's canonical form requirement
   * 
   * @param {BigInt} num - The number that was factorized
   * @param {Map&lt;BigInt, BigInt>} factorization - The factorization result
   * @param {boolean} [isComplete=true] - Whether the factorization is complete
   * @param {number} [confidence=1] - Confidence level for primality (0-1)
   * @param {Object} [options] - Storage options
   * @param {number} [options.computationCost=1] - Relative computational cost (affects retention)
   */
  set(num, factorization, isComplete = true, confidence = 1, options = {}) {
    const key = num.toString()
    const computationCost = options.computationCost || 1
    
    // Validate the factorization for canonical form
    // Each key must be a prime number, supporting the Prime Framework requirement
    for (const [prime] of factorization.entries()) {
      // We don't recheck primality here as it would be inefficient
      // The factorization algorithm is responsible for ensuring prime factors
      if (prime &lt;= 0n) {
        throw new PrimeMathError('Invalid prime factor in factorization', {
          cause: { prime, expected: 'positive prime' }
        })
      }
    }
    
    // Store the factorization with a deep copy to ensure immutability
    this.cache.set(key, {
      factors: new Map(factorization),
      isComplete,
      confidence
    })
    
    // Initialize or update metrics
    const existingMetrics = this.metrics.get(key)
    this.metrics.set(key, {
      lastAccess: Date.now(),
      accessCount: existingMetrics ? existingMetrics.accessCount + 1 : 1,
      computationCost
    })
    
    // Prune if needed
    if (this.cache.size > this.MAX_CACHE_SIZE) {
      this.prune()
    }
    
    // Save to persistent storage if enabled
    // Do this asynchronously to avoid blocking
    if (this.PERSISTENT_CACHE_ENABLED) {
      setTimeout(() => {
        this.saveToStorage()
      }, 0)
    }
  },
  
  /**
   * Prune the cache using a sophisticated policy
   * Prioritizes keeping entries based on a weighted formula that considers:
   * - Computational cost to regenerate
   * - Access frequency (popularity)
   * - Recency of access
   * - Completeness and confidence in the result
   * 
   * This aligns with the Prime Framework's efficiency requirements
   */
  prune() {
    const now = Date.now()
    this.stats.lastPruneTime = now
    
    // If cache isn't significantly over limit, don't prune yet
    if (this.cache.size &lt; this.MAX_CACHE_SIZE * 1.1) {
      return
    }
    
    // Calculate weights for each entry
    const weightedEntries = []
    const maxAge = now - this.stats.lastPruneTime + 1000 // +1s to avoid division by zero
    
    for (const [key, entry] of this.cache.entries()) {
      const metrics = this.metrics.get(key) || { lastAccess: 0, accessCount: 0, computationCost: 1 }
      
      // Age factor (0-1): newer entries have higher values
      const ageValue = Math.max(0, 1 - ((now - metrics.lastAccess) / maxAge))
      
      // Access frequency factor
      const frequencyValue = Math.min(1, metrics.accessCount / 10)
      
      // Computation cost factor: more expensive calculations are preserved
      const costValue = Math.min(1, metrics.computationCost / 10)
      
      // Confidence factor: more confident and complete entries are preserved
      const confidenceValue = entry.isComplete ? entry.confidence : entry.confidence * 0.5
      
      // Combined weight (higher values are more valuable to keep)
      const weight = (
        ageValue * 0.35 +          // 35% weight for recency
        frequencyValue * 0.25 +    // 25% weight for popularity
        costValue * 0.3 +          // 30% weight for computational cost
        confidenceValue * 0.1      // 10% weight for quality of result
      )
      
      weightedEntries.push({ key, weight })
    }
    
    // Sort by weight (ascending)
    weightedEntries.sort((a, b) => a.weight - b.weight)
    
    // Calculate target size after pruning (aim for 80% of maximum)
    const targetSize = Math.floor(this.MAX_CACHE_SIZE * 0.8)
    const removeCount = this.cache.size - targetSize
    
    // Remove the least valuable entries
    for (let i = 0; i &lt; removeCount; i++) {
      if (i &lt; weightedEntries.length) {
        const key = weightedEntries[i].key
        this.cache.delete(key)
        this.metrics.delete(key)
      }
    }
  },
  
  /**
   * Clear the cache
   */
  clear() {
    this.cache.clear()
    this.metrics.clear()
    
    // Reset statistics
    this.stats.hits = 0
    this.stats.misses = 0
    this.stats.total = 0
    this.stats.lastPruneTime = Date.now()
    
    // If persistence is enabled, also clear persistent storage
    if (this.PERSISTENT_CACHE_ENABLED) {
      try {
        if (typeof localStorage !== 'undefined') {
          localStorage.removeItem(this.STORAGE_KEY)
        } else if (typeof global !== 'undefined' &amp;&amp; typeof process !== 'undefined') {
          const fs = require('fs')
          const path = require('path')
          
          const homeDir = process.env.HOME || process.env.USERPROFILE
          if (homeDir) {
            const cachePath = path.join(homeDir, '.math-js-cache')
            const filePath = path.join(cachePath, `${this.STORAGE_KEY}.json`)
            
            if (fs.existsSync(filePath)) {
              fs.unlinkSync(filePath)
            }
          }
        }
      } catch (error) {
        // Fail silently
      }
    }
  },
  
  /**
   * Get the current size of the cache
   * @returns {number} Number of entries in the cache
   */
  size() {
    return this.cache.size
  },
  
  /**
   * Get comprehensive cache statistics
   * @returns {Object} Statistics including hit rate, size, and efficiency metrics
   */
  getStats() {
    const hitRate = this.stats.total > 0 ? this.stats.hits / this.stats.total : 0
    
    return {
      size: this.cache.size,
      maxSize: this.MAX_CACHE_SIZE,
      hits: this.stats.hits,
      misses: this.stats.misses,
      hitRate,
      efficiency: hitRate * (this.cache.size / this.MAX_CACHE_SIZE),
      persistenceEnabled: this.PERSISTENT_CACHE_ENABLED
    }
  },
  
  /**
   * Save the cache to persistent storage if enabled
   * Uses environment-specific storage mechanisms
   * @returns {boolean} True if successfully saved, false otherwise
   */
  saveToStorage() {
    if (!this.PERSISTENT_CACHE_ENABLED) {
      return false
    }
    
    try {
      // Prepare data for serialization
      const serialized = {
        version: 1, // For future compatibility
        timestamp: Date.now(),
        entries: [],
        metrics: []
      }
      
      // Only save the most valuable entries to conserve space
      // This also helps with performance on reload
      const weightedEntries = []
      const now = Date.now()
      
      // Calculate entry weights using the same formula as in prune()
      for (const [key, entry] of this.cache.entries()) {
        const metrics = this.metrics.get(key) || { lastAccess: 0, accessCount: 0, computationCost: 1 }
        
        // Calculate entry weight
        const ageValue = Math.max(0, 1 - ((now - metrics.lastAccess) / (24 * 60 * 60 * 1000)))
        const frequencyValue = Math.min(1, metrics.accessCount / 10)
        const costValue = Math.min(1, metrics.computationCost / 10)
        const confidenceValue = entry.isComplete ? entry.confidence : entry.confidence * 0.5
        
        const weight = (
          ageValue * 0.35 +
          frequencyValue * 0.25 +
          costValue * 0.3 +
          confidenceValue * 0.1
        )
        
        weightedEntries.push({ key, entry, metrics, weight })
      }
      
      // Sort by weight (descending)
      weightedEntries.sort((a, b) => b.weight - a.weight)
      
      // Take only the most valuable entries (limited to MAX_CACHE_SIZE entries)
      const saveCount = Math.min(this.MAX_CACHE_SIZE, weightedEntries.length)
      
      for (let i = 0; i &lt; saveCount; i++) {
        const { key, entry, metrics } = weightedEntries[i]
        
        // Convert the Map to an array for serialization
        const factorArray = []
        for (const [prime, exponent] of entry.factors) {
          factorArray.push([prime.toString(), exponent.toString()])
        }
        
        // Add to serialized data
        serialized.entries.push({
          key,
          factorArray,
          isComplete: entry.isComplete,
          confidence: entry.confidence
        })
        
        serialized.metrics.push({
          key,
          lastAccess: metrics.lastAccess,
          accessCount: metrics.accessCount,
          computationCost: metrics.computationCost
        })
      }
      
      // Serialize and store
      const serializedString = JSON.stringify(serialized)
      
      // Determine storage mechanism based on environment
      if (typeof localStorage !== 'undefined') {
        // Browser environment
        localStorage.setItem(this.STORAGE_KEY, serializedString)
      } else if (typeof global !== 'undefined' &amp;&amp; typeof process !== 'undefined') {
        // Node.js environment
        try {
          const fs = require('fs')
          const path = require('path')
          
          // Try to save to user's home directory
          const homeDir = process.env.HOME || process.env.USERPROFILE
          if (homeDir) {
            const cachePath = path.join(homeDir, '.math-js-cache')
            
            // Create directory if it doesn't exist
            if (!fs.existsSync(cachePath)) {
              fs.mkdirSync(cachePath, { recursive: true })
            }
            
            const filePath = path.join(cachePath, `${this.STORAGE_KEY}.json`)
            fs.writeFileSync(filePath, serializedString, 'utf8')
          }
        } catch (fsError) {
          // Fail silently - persistence is a nice-to-have feature
          return false
        }
      }
      
      return true
    } catch (error) {
      // Fail silently - persistence is a nice-to-have feature
      return false
    }
  },
  
  /**
   * Load the cache from persistent storage if enabled
   * @returns {boolean} True if successfully loaded, false otherwise
   */
  loadFromStorage() {
    if (!this.PERSISTENT_CACHE_ENABLED) {
      return false
    }
    
    try {
      let serializedString = null
      
      // Determine storage mechanism based on environment
      if (typeof localStorage !== 'undefined') {
        // Browser environment
        serializedString = localStorage.getItem(this.STORAGE_KEY)
      } else if (typeof global !== 'undefined' &amp;&amp; typeof process !== 'undefined') {
        // Node.js environment
        try {
          const fs = require('fs')
          const path = require('path')
          
          // Try to load from user's home directory
          const homeDir = process.env.HOME || process.env.USERPROFILE
          if (homeDir) {
            const cachePath = path.join(homeDir, '.math-js-cache')
            const filePath = path.join(cachePath, `${this.STORAGE_KEY}.json`)
            
            if (fs.existsSync(filePath)) {
              serializedString = fs.readFileSync(filePath, 'utf8')
            }
          }
        } catch (fsError) {
          // Fail silently
          return false
        }
      }
      
      if (!serializedString) {
        return false
      }
      
      // Parse the serialized data
      const serialized = JSON.parse(serializedString)
      
      // Version check
      if (serialized.version !== 1) {
        return false
      }
      
      // Check if cache is too old (older than 30 days)
      const cacheAge = Date.now() - serialized.timestamp
      if (cacheAge > 30 * 24 * 60 * 60 * 1000) {
        return false
      }
      
      // Clear the current cache
      this.clear()
      
      // Restore entries to cache
      for (const entry of serialized.entries) {
        // Convert array back to Map
        const factorMap = new Map()
        for (const [primeStr, exponentStr] of entry.factorArray) {
          factorMap.set(BigInt(primeStr), BigInt(exponentStr))
        }
        
        // Add to cache
        this.cache.set(entry.key, {
          factors: factorMap,
          isComplete: entry.isComplete,
          confidence: entry.confidence
        })
      }
      
      // Restore metrics
      for (const metric of serialized.metrics) {
        this.metrics.set(metric.key, {
          lastAccess: metric.lastAccess,
          accessCount: metric.accessCount,
          computationCost: metric.computationCost
        })
      }
      
      // Reset statistics
      this.stats.hits = 0
      this.stats.misses = 0
      this.stats.total = 0
      this.stats.lastPruneTime = Date.now()
      
      return true
    } catch (error) {
      // Fail silently
      return false
    }
  },
  
  /**
   * Enable or disable persistent caching
   * @param {boolean} enabled - Whether persistent caching should be enabled
   */
  setPersistence(enabled) {
    // Update the configuration
    const { configure } = require('./config')
    configure({
      cache: {
        persistentCache: !!enabled
      }
    })
    
    // If enabling, attempt to save the current cache
    if (enabled) {
      this.saveToStorage()
    }
  }
}

/**
 * Factorize a number using trial division
 * Implements Algorithm 1 from the specification for prime factorization
 * 
 * @param {number|string|BigInt} n - The number to factorize
 * @returns {Map&lt;BigInt, BigInt>} A map where keys are prime factors and values are their exponents
 * @throws {PrimeMathError} If n is not a positive integer
 */
function factorize(n) {
  let num = toBigInt(n)

  if (num &lt;= 0n) {
    throw new PrimeMathError('Factorization is only defined for positive integers')
  }

  if (num === 1n) {
    // 1 has no prime factors, return empty map
    return new Map()
  }

  // Initialize the result map for prime factors
  const factors = new Map()
  
  // Check divisibility by 2
  let exponent = 0n
  while (num % 2n === 0n) {
    exponent++
    num /= 2n
  }
  if (exponent > 0n) {
    factors.set(2n, exponent)
  }

  // Check divisibility by odd numbers starting from 3
  let divisor = 3n
  while (divisor * divisor &lt;= num) {
    exponent = 0n
    while (num % divisor === 0n) {
      exponent++
      num /= divisor
    }
    if (exponent > 0n) {
      factors.set(divisor, exponent)
    }
    divisor += 2n
  }

  // If num is greater than 1, it is a prime number
  if (num > 1n) {
    factors.set(num, 1n)
  }

  return factors
}

/**
 * Factorize a number using optimized trial division with precomputed primes
 * This is more efficient for moderately sized numbers
 * 
 * @param {number|string|BigInt} n - The number to factorize
 * @returns {Map&lt;BigInt, BigInt>} A map where keys are prime factors and values are their exponents
 * @throws {PrimeMathError} If n is not a positive integer
 */
function factorizeWithPrimes(n) {
  let num = toBigInt(n)

  if (num &lt;= 0n) {
    throw new PrimeMathError('Factorization is only defined for positive integers')
  }

  if (num === 1n) {
    // 1 has no prime factors, return empty map
    return new Map()
  }

  // Initialize the result map for prime factors
  const factors = new Map()
  
  // Try small primes first (optimization)
  const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n]
  
  // Try each small prime
  for (const prime of smallPrimes) {
    if (num === 1n) break
    
    let exponent = 0n
    while (num % prime === 0n) {
      exponent++
      num /= prime
    }
    if (exponent > 0n) {
      factors.set(prime, exponent)
    }
    
    // Early exit if we've found all factors
    if (prime * prime > num) {
      if (num > 1n) {
        factors.set(num, 1n)
      }
      return factors
    }
  }

  // Continue with trial division for larger primes
  let divisor = 101n // Start from the next prime after our list
  while (divisor * divisor &lt;= num) {
    let exponent = 0n
    while (num % divisor === 0n) {
      exponent++
      num /= divisor
    }
    if (exponent > 0n) {
      factors.set(divisor, exponent)
    }
    divisor += 2n
  }

  // If num is greater than 1, it is a prime number
  if (num > 1n) {
    factors.set(num, 1n)
  }

  return factors
}

/**
 * Miller-Rabin primality test for larger numbers
 * 
 * @param {BigInt} n - The number to test for primality
 * @param {number} k - Number of iterations for accuracy (higher is more accurate)
 * @returns {boolean} True if n is probably prime, false if definitely composite
 */
function millerRabinTest(n, k = 25) {
  if (n &lt;= 1n) return false
  if (n &lt;= 3n) return true
  if (n % 2n === 0n) return false

  // Write n-1 as 2^r * d where d is odd
  let r = 0n
  let d = n - 1n
  while (d % 2n === 0n) {
    d /= 2n
    r++
  }

  // Witness loop
  /**
   * @param {BigInt} a - The base for the witness test
   * @returns {boolean} True if a is a witness for primality
   */
  const witnessLoop = (a) => {
    let x = modularFastExp(a, d, n)
    if (x === 1n || x === n - 1n) return true

    for (let i = 1n; i &lt; r; i++) {
      x = (x * x) % n
      if (x === n - 1n) return true
    }
    return false
  }

  // Test with k random bases
  for (let i = 0; i &lt; k; i++) {
    // Use deterministic bases for small numbers
    // For larger numbers, we'd use random witnesses
    const bases = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n]
    const a = bases[i % bases.length]
    
    if (!witnessLoop(a % (n - 2n) + 2n)) {
      return false
    }
  }
  
  return true
}

/**
 * Fast modular exponentiation for Miller-Rabin test
 * 
 * @param {BigInt} base - Base value
 * @param {BigInt} exponent - Exponent value
 * @param {BigInt} modulus - Modulus for the operation
 * @returns {BigInt} Result of (base^exponent) % modulus
 */
function modularFastExp(base, exponent, modulus) {
  if (modulus === 1n) return 0n
  
  let result = 1n
  base = base % modulus
  
  while (exponent > 0n) {
    if (exponent % 2n === 1n) {
      result = (result * base) % modulus
    }
    exponent = exponent >> 1n
    base = (base * base) % modulus
  }
  
  return result
}

/**
 * Enhanced Pollard's Rho algorithm with cycle detection
 * Optimized for the Prime Framework's factorization requirements
 * 
 * @param {BigInt} n - The number to factor
 * @param {Object} [options] - Algorithm options
 * @param {number} [options.maxIterations] - Maximum number of iterations (if not specified, no limit is applied)
 * @param {BigInt} [options.c=1n] - Polynomial constant
 * @param {number} [options.timeLimit] - Maximum time to spend in milliseconds (if not specified, no time limit is applied)
 * @returns {BigInt} A non-trivial factor of n, or n if no factor is found
 */
function pollardRho(n, options = {}) {
  if (n &lt;= 1n) return n
  if (n % 2n === 0n) return 2n
  if (n % 3n === 0n) return 3n
  
  // If the number is prime, return the number itself
  // This is needed for tests and expected behavior
  if (isPrime(n)) return n
  
  // Get configuration options with fallbacks
  // Note: No default maxIterations - will run until a factor is found or other limits are reached
  const maxIterations = options.maxIterations 
  const timeLimit = options.timeLimit || config.factorization.timeLimit
  const c = options.c !== undefined ? toBigInt(options.c) : 1n
  
  // Define the polynomial function f(x) = (x^2 + c) % n
  const f = (x) => (x * x + c) % n
  
  // Try with different starting values if needed
  const startValues = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n]
  
  // Track start time if we have a time limit
  const startTime = timeLimit ? Date.now() : 0
  
  for (const startValue of startValues) {
    // Initialize with the current start value
    let x = startValue
    let y = startValue
    let d = 1n
    
    // Brent's cycle detection
    let power = 1n
    let lam = 1n
    
    let iterations = 0
    
    // Continue while we haven't found a factor and haven't hit any limits
    while (d === 1n &amp;&amp; 
           // Check iteration limit only if maxIterations is specified
           (maxIterations === undefined || iterations &lt; maxIterations) &amp;&amp;
           // Check time limit only if timeLimit is specified
           (timeLimit === undefined || Date.now() - startTime &lt; timeLimit)) {
      if (lam === power) {
        y = x
        power *= 2n
        lam = 0n
      }
      
      x = f(x)
      lam += 1n
      
      d = gcd((x > y ? x - y : y - x), n)
      
      // Early success - found a factor
      if (d > 1n &amp;&amp; d &lt; n) {
        return d
      }
      
      iterations++
    }
    
    // If we found a factor with this start value, return it
    if (d !== n) {
      return d
    }
  }
  
  // If we tried all start values and didn't find a factor, return n
  return n
}

/**
 * Quadratic Sieve implementation for factoring large numbers
 * Implements a complete and efficient factorization algorithm aligned with the Prime Framework
 * 
 * @param {BigInt} n - The number to factor
 * @param {Object} [options] - Algorithm options
 * @param {number} [options.factorBaseSize=100] - Size of the factor base
 * @param {number} [options.sieveSize=10000] - Size of the sieve interval
 * @param {number} [options.numRelations=0] - Number of relations to collect (0 = auto)
 * @param {boolean} [options.verbose=false] - Whether to output debug info
 * @returns {BigInt} A non-trivial factor of n, or n if no factor is found
 * @throws {PrimeMathError} If input is not a positive composite number
 */
function quadraticSieve(n, options = {}) {
  // Essential argument validation
  n = toBigInt(n)
  
  if (n &lt;= 1n) {
    throw new PrimeMathError('Input must be greater than 1', {
      cause: { value: n, function: 'quadraticSieve' }
    })
  }
  
  // Quick check for small prime factors (optimization)
  if (n % 2n === 0n) return 2n
  if (n % 3n === 0n) return 3n
  if (n % 5n === 0n) return 5n
  
  // Check if n is prime - no need to factor
  if (millerRabinTest(n, 40)) {
    return n // Number is prime, cannot factor
  }
  
  // For very small numbers, use a simpler method
  // Use a dynamic threshold based on config
  const smallNumberThreshold = BigInt(10) ** BigInt(config.factorization.thresholds.trialDivision)
  if (n &lt; smallNumberThreshold) {
    // Find factor by trial division
    for (let i = 7n; i * i &lt;= n; i += 2n) {
      if (n % i === 0n) return i
    }
    return n // Should not reach here if n is composite
  }
  
  // Parse options with better defaults for larger numbers
  const factorBaseSize = options.factorBaseSize || 
    (n &lt; 10n ** 40n ? 100 : 
      n &lt; 10n ** 60n ? 300 : 
        n &lt; 10n ** 80n ? 500 : 1000)
  
  const sieveSize = options.sieveSize || 
    (n &lt; 10n ** 40n ? 10000 : 
      n &lt; 10n ** 60n ? 50000 : 
        n &lt; 10n ** 80n ? 100000 : 200000)
  
  // Let the algorithm automatically determine required relations if not specified
  // Formula: Approximately factorBaseSize + 20 for padding
  const requiredRelations = options.numRelations || (factorBaseSize + 20)
  
  // Step 1: Generate an optimal factor base of small primes
  const factorBase = generateFactorBase(n, factorBaseSize)
  
  // Step 2: Sieve for smooth numbers using optimized quadratic polynomial
  const { relations, matrixSize } = findSmoothNumbers(n, factorBase, sieveSize, requiredRelations)
  
  // If we couldn't find enough relations, the algorithm can't proceed
  if (relations.length &lt; factorBaseSize) {
    // Try again with larger parameters, or return n
    if (options.retry !== true) {
      return quadraticSieve(n, {
        ...options,
        factorBaseSize: factorBaseSize * 1.5,
        sieveSize: sieveSize * 1.5,
        retry: true
      })
    }
    return n
  }
  
  // Step 3: Use Gaussian elimination to find linear dependencies
  // Construct the exponent matrix (each row = relation, each column = prime in factor base)
  const matrix = constructMatrix(relations, factorBase, matrixSize)
  
  // Perform Gaussian elimination to find linear dependencies
  const dependencies = findLinearDependencies(matrix, matrixSize, relations.length)
  
  // Step 4: Use the dependencies to find factors
  for (const dependency of dependencies) {
    // Skip trivial dependencies
    if (dependency.reduce((sum, val) => sum + val, 0) &lt;= 1) continue
    
    // Compute x and y from the dependency
    let x = 1n
    const exponents = new Map()
    
    // Combine all relations in this dependency
    for (let i = 0; i &lt; dependency.length; i++) {
      if (dependency[i] === 1) {
        const relation = relations[i]
        x = (x * relation.x) % n
        
        // Combine factorizations
        for (const [prime, exp] of relation.factorization) {
          const currentExp = exponents.get(prime) || 0n
          exponents.set(prime, (currentExp + exp) % 2n)
        }
      }
    }
    
    // Compute y = sqrt(product of primes^exponents)
    let y = 1n
    for (const [prime, exp] of exponents) {
      // All exponents should be even after our linear algebra
      if (exp % 2n !== 0n) {
        // This should never happen if our algebra is correct
        continue
      }
      
      // Calculate square root by using half the exponent
      y = (y * fastExp(prime, exp / 2n)) % n
    }
    
    // Try to find a factor using the congruence of squares: x² ≡ y² (mod n)
    // This means that (x+y)(x-y) ≡ 0 (mod n)
    // So gcd(x+y, n) or gcd(x-y, n) might be a proper factor
    
    // Case 1: gcd(x+y, n)
    const factor1 = gcd((x + y) % n, n)
    if (factor1 !== 1n &amp;&amp; factor1 !== n) {
      return factor1
    }
    
    // Case 2: gcd(x-y, n)
    const factor2 = gcd((x - y + n) % n, n)
    if (factor2 !== 1n &amp;&amp; factor2 !== n) {
      return factor2
    }
  }
  
  // If we reach here, the algorithm failed to find a proper factor
  // Try again with larger parameters, or return failure
  if (options.retry !== true) {
    return quadraticSieve(n, {
      ...options,
      factorBaseSize: factorBaseSize * 2,
      sieveSize: sieveSize * 2,
      retry: true
    })
  }
  
  return n
}

/**
 * Generate an optimal factor base for the Quadratic Sieve
 * Only include primes p where n is a quadratic residue modulo p
 * 
 * @private
 * @param {BigInt} n - The number to factor
 * @param {number} size - Size of the factor base
 * @returns {BigInt[]} Array of suitable primes for the factor base
 */
function generateFactorBase(n, size) {
  const factorBase = []
  
  // Always include 2 in the factor base
  factorBase.push(2n)
  
  // Start with small primes from the prime cache
  const smallPrimes = primeCache.getSmallPrimes()
  
  // Then check each prime p > 2
  let index = 1 // Skip 2 which we already added
  while (factorBase.length &lt; size &amp;&amp; index &lt; smallPrimes.length) {
    const p = smallPrimes[index++]
    
    // Check if n is a quadratic residue modulo p
    // For p = 2, it always is; for other p, use the Legendre symbol
    if (p === 2n || jacobiSymbol(n % p, p) === 1) {
      factorBase.push(p)
    }
  }
  
  // If we need more primes beyond what's in the cache
  if (factorBase.length &lt; size) {
    let p = smallPrimes[smallPrimes.length - 1] + 2n
    
    while (factorBase.length &lt; size) {
      // Check if p is prime (using our cached primality test)
      if (isPrime(p)) {
        // If p is prime, check if n is a quadratic residue modulo p
        if (jacobiSymbol(n % p, p) === 1) {
          factorBase.push(p)
        }
      }
      
      p += 2n // Only check odd numbers
    }
  }
  
  return factorBase
}

/**
 * Find smooth numbers over the factor base
 * Implements optimized sieving with a quadratic polynomial
 * 
 * @private
 * @param {BigInt} n - The number to factor
 * @param {BigInt[]} factorBase - The factor base of small primes
 * @param {number} sieveSize - Size of each sieve interval
 * @param {number} requiredRelations - Number of relations needed
 * @returns {Object} Object containing the relations and matrix size
 */
function findSmoothNumbers(n, factorBase, sieveSize, requiredRelations) {
  // Find square root of n to use as the starting point for sieving
  const sqrtN = sqrt(n)
  let startValue = sqrtN
  
  // Initialize sieving arrays and structures
  const relations = []
  const largestPrime = factorBase[factorBase.length - 1]
  
  // Precompute Tonelli-Shanks results for all primes in the factor base
  // This maps each prime to its square roots of n modulo p
  const tonelliResults = new Map()
  for (const p of factorBase) {
    if (p === 2n) {
      tonelliResults.set(p, [1n])
    } else {
      tonelliResults.set(p, findTonelliShanks(n, p))
    }
  }
  
  // Sieve until we find enough relations
  let intervalNum = 0
  const maxIntervals = 100 // Safety limit
  
  while (relations.length &lt; requiredRelations &amp;&amp; intervalNum &lt; maxIntervals) {
    intervalNum++
    
    // Initialize sieve array for log approximations
    const sieve = new Array(sieveSize).fill(0)
    
    // Apply sieving over the interval
    for (let i = 0; i &lt; factorBase.length; i++) {
      const p = factorBase[i]
      const roots = tonelliResults.get(p)
      
      // If p has square roots modulo n
      if (roots &amp;&amp; roots.length > 0) {
        // For each root, sieve the interval
        for (const root of roots) {
          // Find the starting positions in the sieve interval
          // We're sieving values of x where x² - n ≡ 0 (mod p)
          let offset = (root - (startValue % p) + p) % p
          
          // Mark multiples of p in the sieve
          for (let j = Number(offset); j &lt; sieve.length; j += Number(p)) {
            // Use logarithmic approximation for efficiency
            sieve[j] += Math.log2(Number(p))
          }
        }
      }
    }
    
    // Find potential smooth numbers
    // Set threshold based on the largest prime in the factor base
    const threshold = Math.log2(Number(largestPrime)) * 0.9
    
    for (let i = 0; i &lt; sieve.length; i++) {
      if (sieve[i] >= threshold) {
        // This is a potential smooth number
        const x = startValue + BigInt(i)
        
        // Compute Q(x) = x² - n
        const qx = (x * x) % n
        
        // Try to factor Q(x) over the factor base
        const factorization = factorizeOverFactorBase(qx, factorBase)
        
        // If Q(x) is indeed smooth (completely factored)
        if (factorization.size > 0) {
          // Add this relation to our collection
          relations.push({
            x,
            qx,
            factorization
          })
          
          // If we have enough relations, stop
          if (relations.length >= requiredRelations) {
            break
          }
        }
      }
    }
    
    // Move to the next sieve interval
    startValue += BigInt(sieveSize)
  }
  
  return {
    relations,
    matrixSize: factorBase.length 
  }
}

/**
 * Factorize a number over a given factor base
 * 
 * @private
 * @param {BigInt} num - The number to factorize
 * @param {BigInt[]} factorBase - The factor base to use
 * @returns {Map&lt;BigInt, BigInt>} Map of prime factors and exponents
 */
function factorizeOverFactorBase(num, factorBase) {
  const factorization = new Map()
  let remaining = num
  
  // Try dividing by each prime in the factor base
  for (const p of factorBase) {
    let exp = 0n
    
    while (remaining % p === 0n) {
      exp++
      remaining /= p
    }
    
    if (exp > 0n) {
      factorization.set(p, exp)
    }
    
    // Early exit: if remaining is 1, we've fully factored the number
    if (remaining === 1n) {
      break
    }
  }
  
  // If remaining is not 1, the number is not smooth over the factor base
  // In that case, we return an empty map
  if (remaining !== 1n) {
    return new Map()
  }
  
  return factorization
}

/**
 * Construct a binary matrix for Gaussian elimination
 * Each row corresponds to a relation
 * Each column corresponds to a prime in the factor base
 * 
 * @private
 * @param {Array&lt;Object>} relations - The relations found during sieving
 * @param {BigInt[]} factorBase - The factor base used
 * @param {number} numPrimes - The number of primes in the factor base
 * @returns {Array&lt;Array&lt;number>>} The exponent matrix (mod 2)
 */
function constructMatrix(relations, factorBase, numPrimes) {
  // Create a map for quick prime index lookup
  const primeIndices = new Map()
  for (let i = 0; i &lt; factorBase.length; i++) {
    primeIndices.set(factorBase[i], i)
  }
  
  // Initialize the matrix with zeros
  const matrix = []
  for (let i = 0; i &lt; relations.length; i++) {
    matrix.push(new Array(numPrimes).fill(0))
  }
  
  // Fill the matrix with exponents mod 2
  for (let i = 0; i &lt; relations.length; i++) {
    const relation = relations[i]
    
    for (const [prime, exponent] of relation.factorization) {
      const primeIndex = primeIndices.get(prime)
      
      // Set the matrix element to exponent mod 2
      if (primeIndex !== undefined) {
        matrix[i][primeIndex] = Number(exponent % 2n)
      }
    }
  }
  
  return matrix
}

/**
 * Find linear dependencies using Gaussian elimination
 * The key part of the quadratic sieve algorithm
 * 
 * @private
 * @param {Array&lt;Array&lt;number>>} matrix - The binary matrix
 * @param {number} numCols - Number of columns (primes)
 * @param {number} numRows - Number of rows (relations)
 * @returns {Array&lt;Array&lt;number>>} Array of dependency vectors
 */
function findLinearDependencies(matrix, numCols, numRows) {
  // Create an augmented matrix for tracking dependencies
  // [original matrix | identity matrix]
  const augMatrix = []
  for (let i = 0; i &lt; numRows; i++) {
    const row = [...matrix[i]]
    
    // Add identity part
    for (let j = 0; j &lt; numRows; j++) {
      row.push(i === j ? 1 : 0)
    }
    
    augMatrix.push(row)
  }
  
  // Perform Gaussian elimination to transform the matrix to row echelon form
  // This is in GF(2), so addition is XOR and multiplication is AND
  for (let j = 0; j &lt; numCols &amp;&amp; j &lt; numRows; j++) {
    // Find a pivot row
    let pivotRow = -1
    for (let i = j; i &lt; numRows; i++) {
      if (augMatrix[i][j] === 1) {
        pivotRow = i
        break
      }
    }
    
    // If no pivot found, continue to next column
    if (pivotRow === -1) continue
    
    // Swap rows if needed
    if (pivotRow !== j) {
      [augMatrix[j], augMatrix[pivotRow]] = [augMatrix[pivotRow], augMatrix[j]]
    }
    
    // Eliminate other rows
    for (let i = 0; i &lt; numRows; i++) {
      if (i !== j &amp;&amp; augMatrix[i][j] === 1) {
        // In GF(2), this is equivalent to XOR
        for (let k = j; k &lt; augMatrix[i].length; k++) {
          augMatrix[i][k] = (augMatrix[i][k] + augMatrix[j][k]) % 2
        }
      }
    }
  }
  
  // Extract dependencies from the augmented matrix
  // A dependency corresponds to a row with all zeros in the left part
  const dependencies = []
  
  for (let i = 0; i &lt; numRows; i++) {
    let isZeroRow = true
    
    // Check if the left part (original matrix) is all zeros
    for (let j = 0; j &lt; numCols; j++) {
      if (augMatrix[i][j] === 1) {
        isZeroRow = false
        break
      }
    }
    
    // If left part is all zeros, extract the right part (dependency)
    if (isZeroRow) {
      const dependency = augMatrix[i].slice(numCols)
      dependencies.push(dependency)
    }
  }
  
  return dependencies
}

/**
 * Calculate the Jacobi symbol (a/n)
 * Used by the Quadratic Sieve algorithm
 * 
 * @private
 * @param {BigInt} a - The numerator
 * @param {BigInt} n - The denominator
 * @returns {number} The Jacobi symbol (1, 0, or -1)
 */
function jacobiSymbol(a, n) {
  if (n &lt;= 0n || n % 2n === 0n) {
    throw new PrimeMathError('Jacobi symbol denominator must be a positive odd number')
  }
  
  // Reduce a modulo n
  a = ((a % n) + n) % n
  
  let result = 1
  
  // Compute the Jacobi symbol using quadratic reciprocity
  while (a !== 0n) {
    // Extract the largest power of 2 from a
    let t = 0n
    while (a % 2n === 0n) {
      a /= 2n
      t++
    }
    
    // Apply quadratic reciprocity for powers of 2
    if (t % 2n === 1n) {
      const nMod8 = Number(n % 8n)
      if (nMod8 === 3 || nMod8 === 5) {
        result = -result
      }
    }
    
    // Apply quadratic reciprocity for odd values
    if (a % 4n === 3n &amp;&amp; n % 4n === 3n) {
      result = -result
    }
    
    // Swap and continue
    const temp = a
    a = n % a
    n = temp
  }
  
  if (n === 1n) {
    return result
  }
  
  return 0 // If n is not 1 at the end, a and n have a common factor
}

/**
 * Find square roots modulo a prime using the Tonelli-Shanks algorithm
 * Used by the Quadratic Sieve for finding starting positions
 * 
 * @private
 * @param {BigInt} n - The number to find square roots for
 * @param {BigInt} p - The prime modulus
 * @returns {BigInt[]} An array of square roots of n modulo p
 */
function findTonelliShanks(n, p) {
  // Handle trivial cases
  if (p === 2n) return [1n]
  
  // Ensure n is reduced modulo p
  n = ((n % p) + p) % p
  
  // Check if n is a quadratic residue
  if (jacobiSymbol(n, p) !== 1) {
    return []
  }
  
  // Tonelli-Shanks algorithm for p ≡ 3 (mod 4)
  if (p % 4n === 3n) {
    const r = fastExp(n, (p + 1n) / 4n) % p
    return [r, p - r]
  }
  
  // Find Q and S such that p - 1 = Q * 2^S with Q odd
  let Q = p - 1n
  let S = 0n
  while (Q % 2n === 0n) {
    Q /= 2n
    S++
  }
  
  // Find a non-residue z
  let z = 2n
  while (jacobiSymbol(z, p) !== -1) {
    z++
  }
  
  // Initialize variables
  let M = S
  let c = fastExp(z, Q) % p
  let t = fastExp(n, Q) % p
  let R = fastExp(n, (Q + 1n) / 2n) % p
  
  // Main loop
  while (t !== 1n) {
    if (t === 0n) return [0n]
    if (t === 1n) return [R, p - R]
    
    // Find the least i such that t^(2^i) ≡ 1 (mod p)
    let i = 0n
    let temp = t
    while (temp !== 1n) {
      temp = (temp * temp) % p
      i++
      if (i >= M) return [] // Should not happen, just a safeguard
    }
    
    // Compute b
    let b = c
    for (let j = 0n; j &lt; M - i - 1n; j++) {
      b = (b * b) % p
    }
    
    // Update variables
    M = i
    c = (b * b) % p
    t = (t * c) % p
    R = (R * b) % p
    
    if (t === 1n) {
      return [R, p - R]
    }
  }
}

/**
 * Integer square root function
 * 
 * @private
 * @param {BigInt} n - Input value
 * @returns {BigInt} Integer square root of n
 */
function sqrt(n) {
  if (n &lt; 0n) {
    throw new PrimeMathError('Cannot compute square root of negative number')
  }
  
  if (n &lt; 2n) {
    return n
  }
  
  // Newton's method for square root
  let x = n
  let y = (x + 1n) / 2n
  
  while (y &lt; x) {
    x = y
    y = (x + n / x) / 2n
  }
  
  return x
}

/**
 * Lenstra's Elliptic Curve Method (ECM) for factorization
 * Optimized for finding medium-sized factors of large numbers
 * Enhanced with Prime Framework optimizations for universal coordinates
 * 
 * This implementation uses configurable parameters for number of curves, bounds, and memory limits.
 * All limits can be set either through the options parameter or via the global configuration 
 * system in config.factorization.ecm.
 * 
 * @param {BigInt} n - The number to factor
 * @param {Object} [options] - Algorithm options
 * @param {number} [options.curves] - Number of curves to try (default: config.factorization.ecm.maxCurves or scaled by number size)
 * @param {number} [options.b1] - Stage 1 bound (default: config.factorization.ecm.defaultB1)
 * @param {number} [options.b2] - Stage 2 bound (default: config.factorization.ecm.defaultB2 or b1*100 if 0)
 * @param {number} [options.maxMemory] - Max memory usage in MB (default: config.factorization.ecm.maxMemory or config.factorization.memoryLimit)
 * @returns {BigInt} A non-trivial factor of n, or n if no factor is found
 * @throws {PrimeMathError} If input is not a positive composite number
 */
function ellipticCurveMethod(n, options = {}) {
  // Validate input and handle special cases
  n = toBigInt(n)
  
  if (n &lt;= 1n) {
    throw new PrimeMathError('Input must be greater than 1', {
      cause: { value: n, function: 'ellipticCurveMethod' }
    })
  }
  
  // Quick checks for small divisors - fast path for efficiency
  if (n % 2n === 0n) return 2n
  if (n % 3n === 0n) return 3n
  if (n % 5n === 0n) return 5n
  if (n % 7n === 0n) return 7n
  
  // Check if the input is prime
  if (millerRabinTest(n, 25)) {
    return n // Number is prime, cannot factor further
  }
  
  // For small numbers, use a simpler method
  // Use a dynamic threshold based on config
  const smallNumberThreshold = BigInt(10) ** BigInt(config.factorization.thresholds.trialDivision)
  if (n &lt; smallNumberThreshold) {
    // Prime Framework optimization: Use trial division with small prime cache
    const smallPrimes = primeCache.getSmallPrimes()
    for (const p of smallPrimes) {
      if (p * p > n) break
      if (n % p === 0n) return p
    }
    
    // Continue with trial division for larger primes
    for (let i = 1009n; i * i &lt;= n; i += 2n) {
      if (n % i === 0n) return i
    }
    return n
  }
  
  // Parse options with improved defaults from config
  // Scale parameters based on the size of n
  const digits = n.toString().length
  
  // Get ECM configuration settings
  const ecmConfig = config.factorization.ecm
  
  // Curves: Scale based on number size but respect maxCurves config
  const curveBase = 20 + Math.floor(digits / 5)
  const configMaxCurves = ecmConfig.maxCurves
  const curves = options.curves || Math.min(curveBase, configMaxCurves)
  
  // B1 bound: Scale based on number size using configurable factor
  const b1Base = options.b1 || ecmConfig.defaultB1
  const b1ScaleFactor = ecmConfig.b1ScaleFactor
  // Ensure b1 is a valid integer by rounding
  const b1 = Math.round(b1Base * Math.pow(b1ScaleFactor, Math.min(digits - 15, 15)))
  
  // B2 bound: Use provided value, calculated from B1, or config default
  const b2 = options.b2 || ecmConfig.defaultB2 || (b1 * 100)
  
  // Memory limit: Use provided value or config default
  const maxMemory = options.maxMemory || 
    (config.factorization.memoryLimit || ecmConfig.maxMemory || ecmConfig.defaultMemory)
  
  // Memory limit for stage 2 (in elements)
  const maxElements = maxMemory ? (maxMemory * 1024 * 1024) / 16 : Number.MAX_SAFE_INTEGER // 16 bytes per element
  
  // Prime Framework enhancement: Use prime cache for better performance
  // Precompute primes up to B1 using the cached prime generator
  const smallPrimesUpperBound = Math.min(b1, 100000)
  const primesUpToB1 = []
  
  // Use cached small primes
  const cachedPrimes = primeCache.getSmallPrimes()
  for (const p of cachedPrimes) {
    if (Number(p) &lt;= smallPrimesUpperBound) {
      primesUpToB1.push(Number(p))
    }
  }
  
  // Generate larger primes if needed
  if (smallPrimesUpperBound > Number(cachedPrimes[cachedPrimes.length - 1])) {
    // Use a simple trial division to generate additional primes if needed
    const maxPrime = BigInt(smallPrimesUpperBound)
    let currentPrime = cachedPrimes[cachedPrimes.length - 1] + 2n
    
    while (currentPrime &lt;= maxPrime) {
      let isPrimeVal = true
      
      // Check divisibility by all known primes
      for (const p of cachedPrimes) {
        if (p * p > currentPrime) break // Optimization
        
        if (currentPrime % p === 0n) {
          isPrimeVal = false
          break
        }
      }
      
      if (isPrimeVal) {
        primesUpToB1.push(Number(currentPrime))
      }
      
      currentPrime += 2n // Skip even numbers
    }
  }
  
  // Try multiple curve-point pairs to increase chances of finding a factor
  for (let curve = 0; curve &lt; curves; curve++) {
    // Generate deterministic parameters for the curve and point
    // This is a Prime Framework optimization for reproducible results
    const seed = BigInt(curve + 1)
    
    // Generate pseudorandom parameters using a simple PRNG
    // Ensuring they satisfy the curve equation: y^2 = x^3 + ax + b (mod n)
    const sigma = ((seed * seed + 3n) * seed) % n
    if (sigma === 0n || sigma === 1n) continue
    
    // Compute curve parameters using Montgomery parametrization
    // This is more efficient than Weierstrass form for ECM
    const u = (sigma * sigma - 5n) % n
    const v = (4n * sigma) % n
    
    // Compute A parameter for the Montgomery form: By^2 = x^3 + Ax^2 + x
    let A = ((v - u) * modInverse((4n * u * v) % n, n)) % n
    if (A &lt; 0n) A += n
    
    // Compute the starting point (x:z) in projective coordinates
    let point = { x: u, z: v }
    
    try {
      // Stage 1: Scalar multiplication with prime powers up to B1
      for (const p of primesUpToB1) {
        // For each prime, find largest power &lt;= B1
        let q = p
        while (q &lt;= b1 / p) {
          q *= p
        }
        
        // Multiply the point by q
        point = montgomeryLadder(point, BigInt(q), A, n)
        
        // Check for a non-trivial GCD
        const gcdVal = gcd(point.z, n)
        if (gcdVal !== 1n &amp;&amp; gcdVal !== n) {
          return gcdVal // Found a factor!
        }
      }
      
      // Stage 2: Process additional primes between B1 and B2
      if (b2 > b1 &amp;&amp; point.z !== 0n) {
        const factor = ecmStage2(point, A, n, b1, b2, maxElements)
        if (factor !== 1n &amp;&amp; factor !== n) {
          return factor
        }
      }
    } catch (error) {
      // If we encounter a GCD in modular inversion, that's a factor!
      if (error instanceof Error &amp;&amp; error.cause &amp;&amp; error.cause.gcd) {
        const factor = error.cause.gcd
        if (factor !== 1n &amp;&amp; factor !== n) {
          return factor
        }
      }
    }
  }
  
  // If no factor found after trying all curves, return n
  return n
}

/**
 * Stage 2 of the ECM algorithm using improved continuation
 * Prime Framework enhanced for better performance
 * 
 * This implementation uses a configurable baby-step/giant-step approach
 * with memory constraints determined by the maxElements parameter.
 * The algorithm dynamically adjusts the parameters to work within
 * the specified memory constraints.
 * 
 * @private
 * @param {Object} P - Starting point from Stage 1 in Montgomery form
 * @param {BigInt} A - Curve parameter A
 * @param {BigInt} n - Number to factor
 * @param {number} b1 - Stage 1 bound
 * @param {number} b2 - Stage 2 bound
 * @param {number} maxElements - Memory constraint (number of point elements that can be stored)
 * @returns {BigInt} A factor of n, or 1 if none found
 */
function ecmStage2(P, A, n, b1, b2, maxElements) {
  // Prime Framework optimization: Efficient stage 2 implementation
  // Using the "standard continuation" approach
  
  // Compute d = gcd(2 * D, n) where D is the denominator in point doubling
  const gcdVal = gcd(2n * P.z, n)
  if (gcdVal !== 1n) {
    return gcdVal // Found a factor
  }
  
  // Initialize accumulator for batch GCD
  let acc = 1n
  
  // Determine optimal parameters for baby-step/giant-step
  const D = Math.floor(Math.sqrt(b2 - b1))
  const numGiants = Math.min(Math.ceil((b2 - b1) / D), maxElements)
  
  // Compute [P], [2P], [3P], ..., [D-1]P using Montgomery's ladder
  const babySteps = []
  let Q = P // Q = P
  babySteps.push(Q)
  
  for (let i = 2; i &lt; D; i++) {
    Q = montgomeryCombine(babySteps[0], babySteps[i-2], Q, A, n)
    babySteps.push(Q)
  }
  
  // Compute [D]P as the giant step
  const giantStep = montgomeryLadder(P, BigInt(D), A, n)
  
  // Initialize current point at the multiple of D just below B1
  let d = Math.floor(b1 / D) * D
  let S = montgomeryLadder(P, BigInt(d), A, n)
  
  // Process each giant step: S = S + [D]P
  for (let i = 0; i &lt; numGiants &amp;&amp; d &lt; b2; i++) {
    d += D
    const oldS = S
    S = montgomeryCombine(giantStep, oldS, P, A, n)
    
    // For each baby step point, compute the GCD accumulator
    for (let j = 0; j &lt; babySteps.length; j++) {
      const mj = d - j
      if (mj > b1 &amp;&amp; mj &lt;= b2 &amp;&amp; isPrime(BigInt(mj))) {
        // Compute the "difference" between S and babySteps[j-1]
        const diff = montgomeryCombine(S, babySteps[j-1], P, A, n, true)
        
        // Batch GCD: accumulate differences
        acc = (acc * diff.z) % n
        
        // Occasionally check for a factor to avoid overflow
        if (i % 100 === 99) {
          const g = gcd(acc, n)
          if (g !== 1n &amp;&amp; g !== n) {
            return g
          }
          acc = 1n
        }
      }
    }
  }
  
  // Final GCD check
  if (acc !== 1n) {
    const g = gcd(acc, n)
    if (g !== 1n &amp;&amp; g !== n) {
      return g
    }
  }
  
  return 1n
}

/**
 * Montgomery ladder for scalar multiplication
 * Computes k*P on Montgomery curve in a constant-time manner
 * 
 * @private
 * @param {Object} P - Point in projective coordinates {x, z}
 * @param {BigInt} k - Scalar multiplier
 * @param {BigInt} A - Curve parameter
 * @param {BigInt} n - Modulus
 * @returns {Object} Resulting point k*P
 */
function montgomeryLadder(P, k, A, n) {
  let R0 = { x: 1n, z: 0n } // Point at infinity
  let R1 = { ...P } // Copy the point
  
  // Scalar multiplication using Montgomery ladder
  // This is a constant-time algorithm (important for cryptographic applications)
  const bits = k.toString(2).split('').map(Number)
  
  for (let i = 0; i &lt; bits.length; i++) {
    const bit = bits[i]
    
    if (bit === 0) {
      R1 = montgomeryCombine(R0, R1, P, A, n)
      R0 = montgomeryDouble(R0, A, n)
    } else {
      R0 = montgomeryCombine(R0, R1, P, A, n)
      R1 = montgomeryDouble(R1, A, n)
    }
  }
  
  return R0
}

/**
 * Montgomery point doubling
 * Computes 2P on Montgomery curve By^2 = x^3 + Ax^2 + x
 * 
 * @private
 * @param {Object} P - Point in projective coordinates {x, z}
 * @param {BigInt} A - Curve parameter
 * @param {BigInt} n - Modulus
 * @returns {Object} Resulting point 2P
 */
function montgomeryDouble(P, A, n) {
  if (P.z === 0n) return P // Point at infinity
  
  // Compute u = (x + z)^2
  const u = ((P.x + P.z) * (P.x + P.z)) % n
  
  // Compute v = (x - z)^2
  const v = ((P.x - P.z) * (P.x - P.z)) % n
  
  // Compute x' = u * v
  const x = (u * v) % n
  
  // Compute w = 4xz = u - v
  let wValue = (u - v) % n
  if (wValue &lt; 0n) wValue += n
  
  // Compute z' = ((u - v) * ((A + 2) / 4 * u + v)) % n
  const t = ((((A + 2n) * u) / 4n) + v) % n
  const z = (wValue * t) % n
  
  return { x, z }
}

/**
 * Montgomery differential addition
 * Computes P+Q given P, Q, and P-Q
 * 
 * @private
 * @param {Object} P - First point
 * @param {Object} Q - Second point
 * @param {Object} PminusQ - Difference P-Q (or base point)
 * @param {BigInt} A - Curve parameter
 * @param {BigInt} n - Modulus
 * @param {boolean} [returnDifference=false] - Whether to return the z-coordinate of P-Q
 * @returns {Object} Resulting point P+Q or the difference info
 */
function montgomeryCombine(P, Q, PminusQ, A, n, returnDifference = false) {
  // Special cases: points at infinity
  if (P.z === 0n) return Q
  if (Q.z === 0n) return P
  
  // Compute u = (x_P + z_P) * (x_Q - z_Q)
  const u = ((P.x + P.z) * (Q.x - Q.z)) % n
  
  // Compute v = (x_P - z_P) * (x_Q + z_Q)
  const v = ((P.x - P.z) * (Q.x + Q.z)) % n
  
  // Compute w = u + v
  let w = (u + v) % n
  if (w &lt; 0n) w += n
  
  // Compute t = u - v
  let t = (u - v) % n
  if (t &lt; 0n) t += n
  
  // Compute the result
  const x = (PminusQ.x * w * w) % n
  const z = (PminusQ.z * t * t) % n
  
  if (returnDifference) {
    return { z: t }
  }
  
  return { x, z }
}

/**
 * Compute modular inverse with GCD factorization detection
 * 
 * @private
 * @param {BigInt} a - Value to invert
 * @param {BigInt} n - Modulus
 * @returns {BigInt} Multiplicative inverse of a modulo n
 * @throws {Error} If inversion fails, with the GCD information in the error cause
 */
function modInverse(a, n) {
  a = ((a % n) + n) % n // Ensure a is positive and &lt; n
  
  // Extended Euclidean Algorithm
  let t = 0n, newt = 1n
  let r = n, newr = a
  
  while (newr !== 0n) {
    const quotient = r / newr
    const tempT = newt
    newt = t - quotient * newt
    t = tempT
    
    const tempR = newr
    newr = r - quotient * newr
    r = tempR
  }
  
  // If r > 1, a is not invertible, but we found a factor!
  if (r > 1n) {
    const error = new Error('Modular inverse does not exist - GCD found', {
      cause: { gcd: r }
    })
    throw error
  }
  
  // Adjust to positive value
  if (t &lt; 0n) t += n
  
  return t
}

/* Commented out unused ECM functions
/**
 * Point addition for elliptic curve method
 * This function is not currently used but is kept for future reference
 * and for completeness of the implementation
 * 
 * @private
 * @param {Object} p1 - First point {x, y, z?}
 * @param {Object} p2 - Second point {x, y, z?}
 * @param {BigInt} a - Curve parameter a 
 * @param {BigInt} n - Modulus
 * @returns {Object} Resulting point {x, y, z}
 */
/* function ecmAdd(p1, p2, a, n) {
  // Handle projective coordinates
  const p1z = p1.z || 1n
  const p2z = p2.z || 1n
  
  // Check if points are the same
  if (p1.x === p2.x &amp;&amp; p1.y === p2.y &amp;&amp; p1z === p2z) {
    return ecmDouble(p1, a, n)
  }
  
  // Different points - compute addition
  try {
    // Convert to projective coordinates for faster computation
    const z1z1 = (p1z * p1z) % n
    const z2z2 = (p2z * p2z) % n
    const u1 = (p1.x * z2z2) % n
    const u2 = (p2.x * z1z1) % n
    const s1 = (p1.y * p2z * z2z2) % n
    const s2 = (p2.y * p1z * z1z1) % n
    
    if (u1 === u2) {
      if (s1 !== s2) {
        // Points are inverses of each other - return point at infinity
        return { x: 0n, y: 1n, z: 0n }
      } else {
        // Points are the same - use doubling
        return ecmDouble(p1, a, n)
      }
    }
    
    let h = (u2 - u1) % n
    if (h &lt; 0n) h += n
    
    const i = (4n * h * h) % n
    const j = (h * i) % n
    let r = (2n * (s2 - s1)) % n
    if (r &lt; 0n) r += n
    
    const v = (u1 * i) % n
    
    // Compute new x
    let x3 = (r * r - j - 2n * v) % n
    if (x3 &lt; 0n) x3 += n
    
    // Compute new y
    let y3 = (r * (v - x3) - 2n * s1 * j) % n
    if (y3 &lt; 0n) y3 += n
    
    // Compute new z
    let z3 = (2n * h * p1z * p2z) % n
    
    return { x: x3, y: y3, z: z3 }
  } catch (error) {
    // If we encounter division by zero, it means we found a factor
    const factor = gcd(error.divisor, n)
    if (factor > 1n &amp;&amp; factor &lt; n) {
      const err = new Error('GCD found during ECM')
      err.factor = factor
      throw err
    }
    throw error
  }
}

/**
 * Point doubling for elliptic curve method
 * 
 * @private
 * @param {Object} p - Point to double {x, y, z?}
 * @param {BigInt} a - Curve parameter a
 * @param {BigInt} n - Modulus
 * @returns {Object} Doubled point {x, y, z}
 */
// eslint-disable-next-line no-unused-vars
function ecmDouble(p, a, n) {
  // Handle projective coordinates
  const z = p.z || 1n
  
  if (p.y === 0n || z === 0n) {
    // Point at infinity or y=0
    return { x: 0n, y: 1n, z: 0n }
  }
  
  try {
    const xx = (p.x * p.x) % n
    const zz = (z * z) % n
    const yyyy = (p.y * p.y * p.y * p.y) % n
    
    let s = (4n * p.x * yyyy) % n
    let m = (3n * xx + a * zz * zz) % n
    if (m &lt; 0n) m += n
    
    // Compute new x
    let x3 = (m * m - 2n * s) % n
    if (x3 &lt; 0n) x3 += n
    
    // Compute new y
    let y3 = (m * (s - x3) - 8n * yyyy) % n
    if (y3 &lt; 0n) y3 += n
    
    // Compute new z
    let z3 = (2n * p.y * z) % n
    
    return { x: x3, y: y3, z: z3 }
  } catch (error) {
    // If we encounter division by zero, it means we found a factor
    const factor = gcd(error.divisor, n)
    if (factor > 1n &amp;&amp; factor &lt; n) {
      const err = new Error('GCD found during ECM')
      err.factor = factor
      throw err
    }
    throw error
  }
}

/**
 * Scalar multiplication for elliptic curve method
 * 
 * @private
 * @param {Object} p - Base point {x, y, z?}
 * @param {BigInt} k - Scalar multiplier
 * @param {BigInt} a - Curve parameter a
 * @param {BigInt} n - Modulus
 * @returns {Object} Resulting point k*P
 */
// This function is not currently used but is kept for future reference
// and for completeness of the implementation
/* 
function ecmMultiply(p, k, a, n) {
  if (k === 0n) {
    return { x: 0n, y: 1n, z: 0n } // Point at infinity
  }
  
  if (k === 1n) {
    return p
  }
  
  // Use binary method for fast multiplication
  let result = { x: 0n, y: 1n, z: 0n } // Start with infinity point
  let current = { ...p } // Copy of the base point
  let kBinary = k
  
  while (kBinary > 0n) {
    if (kBinary % 2n === 1n) {
      // If current bit is set, add current point to result
      result = ecmAdd(result, current, a, n)
    }
    // Double the current point
    current = ecmDouble(current, a, n)
    // Move to next bit
    kBinary = kBinary >> 1n
  }
  
  return result
}
*/

/**
 * Recursively find factors using enhanced factorization algorithms
 * Optimized with Prime Framework techniques for finding factors
 * Implements a sophisticated approach that selects the most efficient algorithm
 * for each phase of the factorization, following the Prime Framework requirements
 * 
 * @param {BigInt} n - The number to factorize
 * @param {Map&lt;BigInt, BigInt>} factors - The current factor map
 * @param {Object} [options] - Algorithm options
 * @returns {Map&lt;BigInt, BigInt>} Updated factor map
 */
function findFactorsPollardRho(n, factors = new Map(), options = {}) {
  // Base case: n is 1, no further factorization needed
  if (n === 1n) return factors
  
  // Check the factorization cache first for efficiency
  const cachedFactors = _factorizationCache.get(n)
  if (cachedFactors) {
    // Merge the cached factors into our current factors
    for (const [prime, exponent] of cachedFactors.factors.entries()) {
      const currentExp = factors.get(prime) || 0n
      factors.set(prime, currentExp + exponent)
    }
    return factors
  }
  
  // Check if n is prime using optimized primality test
  // For the Prime Framework, it's critical to correctly identify primes
  if (isPrime(n)) {
    // n is prime, add it to factors
    const currentExp = factors.get(n) || 0n
    factors.set(n, currentExp + 1n)
    
    // Cache this result with 100% confidence
    _factorizationCache.set(n, new Map([[n, 1n]]), true, 1.0, {
      computationCost: 1 // Low cost for prime factorization
    })
    
    return factors
  }
  
  // Determine the best factorization method based on the size and structure of n
  // This implements the adaptive approach described in the Prime Framework spec
  let factor
  
  // Get the approximate number of decimal digits in n
  const numDigits = n.toString().length
  
  if (n &lt; 10000n) {
    // For small numbers, trial division is most efficient
    factor = findFactorByTrialDivision(n)
  } else if (n &lt; 10n ** 12n) {
    // For medium-sized numbers up to 12 digits, standard Pollard's rho
    factor = pollardRho(n, options)
  } else if (n &lt; 10n ** 25n) {
    // For larger numbers up to 25 digits, enhanced Pollard's rho with better parameters
    // This follows the Prime Framework's emphasis on exact factorization efficiency
    factor = pollardRho(n, {
      ...options,
      timeLimit: options.timeLimit || 10000, // 10 seconds default timeout
      // Try multiple values of c for better chances of finding a factor
      c: (options.iteration || 0) % 5 === 0 ? 1n : 
        (options.iteration || 0) % 5 === 1 ? 2n :
          (options.iteration || 0) % 5 === 2 ? 3n :
            (options.iteration || 0) % 5 === 3 ? -1n : 7n
    })
    
    // If standard Pollard's rho failed, try ECM with modest parameters
    if (factor === n) {
      factor = ellipticCurveMethod(n, {
        curves: 5,
        b1: 10000
      })
    }
  } else if (n &lt; 10n ** 40n) {
    // For even larger numbers up to 40 digits, use ECM with parameters scaled to the input size
    // The Prime Framework emphasizes efficient factorization of universal coordinates
    factor = ellipticCurveMethod(n, {
      curves: options.ecmCurves || Math.min(15, 5 + Math.floor(numDigits / 5)),
      b1: options.ecmB1 || 50000 * Math.floor(numDigits / 10),
      b2: options.ecmB2 || 0 // Skip stage 2 for smaller numbers
    })
    
    // If ECM failed, try Quadratic Sieve with modest parameters
    if (factor === n &amp;&amp; options.advanced) {
      factor = quadraticSieve(n, {
        factorBaseSize: options.qsFactorBase || 100,
        sieveSize: options.qsSieveSize || 10000
      })
    }
  } else {
    // For very large numbers (> 40 digits), use Quadratic Sieve with parameters scaled to the input size
    // The Prime Framework requires efficient factorization even for extremely large numbers
    factor = quadraticSieve(n, {
      factorBaseSize: options.qsFactorBase || Math.min(500, 100 + Math.floor(numDigits / 5) * 20),
      sieveSize: options.qsSieveSize || Math.min(100000, 10000 + numDigits * 1000),
      verbose: options.verbose
    })
    
    // If QS failed for very large numbers and advanced options are enabled,
    // try ECM with more aggressive parameters as a last resort
    if (factor === n &amp;&amp; options.advanced) {
      factor = ellipticCurveMethod(n, {
        curves: options.ecmCurves || 30,
        b1: options.ecmB1 || 1000000, // Default to a reasonable value with no upper limit
        b2: options.ecmB2 || 100000000
      })
    }
  }
  
  // Handle the case where no factor was found
  if (factor === n) {
    // If all methods failed to find a proper factor despite n being composite,
    // we need to make a decision based on the Prime Framework requirements
    
    if (options.partialFactorization) {
      // If partial factorization is allowed, treat n as prime-like and continue
      const currentExp = factors.get(n) || 0n
      factors.set(n, currentExp + 1n)
      
      // Cache this result, but with a lower confidence
      // Scale confidence based on the exhaustiveness of our search
      const confidence = options.advanced ? 0.95 : 0.8
      _factorizationCache.set(n, new Map([[n, 1n]]), false, confidence, {
        computationCost: 10 // High cost factor to preserve this in cache longer
      })
      
      return factors
    } else if (options.iteration &amp;&amp; options.iteration &lt; 3) {
      // Try again with a different approach if we haven't tried too many times
      return findFactorsPollardRho(n, factors, {
        ...options,
        iteration: (options.iteration || 0) + 1,
        // Try a different c parameter for Pollard's rho
        c: (options.c || 1n) + 1n
      })
    } else {
      // If we've exhausted all options, treat as prime
      // This aligns with the Prime Framework's requirement for deterministic outcomes
      const currentExp = factors.get(n) || 0n
      factors.set(n, currentExp + 1n)
      
      // Cache with appropriate confidence level
      const confidence = isPrime(n, { useCache: false }) ? 1.0 : 0.9
      _factorizationCache.set(n, new Map([[n, 1n]]), true, confidence)
      
      return factors
    }
  }
  
  // We found a proper factor - recursively factor both parts
  // This follows the Prime Framework's divide-and-conquer approach
  
  // Add iteration count to track recursion depth
  const newOptions = {
    ...options,
    iteration: 0 // Reset iteration counter for the new factorization
  }
  
  // Factor the found factor first
  findFactorsPollardRho(factor, factors, newOptions)
  
  // Then factor the quotient
  findFactorsPollardRho(n / factor, factors, newOptions)
  
  return factors
}

/**
 * Find a factor by efficient trial division
 * Fast method for small numbers using a deterministic approach
 * Follows the Prime Framework's requirement for reliable factorization
 * 
 * @private
 * @param {BigInt} n - The number to factor
 * @returns {BigInt} A factor of n
 */
function findFactorByTrialDivision(n) {
  // Check small primes first from the prime cache
  for (const prime of primeCache.getSmallPrimes()) {
    if (n % prime === 0n) {
      return prime
    }
    if (prime * prime > n) break
  }
  
  // Calculate the limit for trial division
  const sqrtN = sqrt(n)
  
  // Start trial division with odd numbers beyond our small prime list
  // Use a wheel factorization pattern skipping multiples of 2 and 3
  // This gives us numbers of form 6k-1 and 6k+1
  const startDiv = 101n
  
  for (let i = startDiv; i &lt;= sqrtN; i += 2n) {
    if (n % i === 0n) {
      return i
    }
  }
  
  // If no factors found, the number is prime
  return n
}

/**
 * Factorize a large number using enhanced Pollard's Rho algorithm
 * Improved with Prime Framework optimizations for performance
 * 
 * @param {number|string|BigInt} n - The number to factorize
 * @param {Object} [options] - Factorization options
 * @param {boolean} [options.useCache=true] - Whether to use factorization cache
 * @param {boolean} [options.perfectFactorization=true] - Whether to ensure complete factorization
 * @returns {Map&lt;BigInt, BigInt>} A map where keys are prime factors and values are their exponents
 * @throws {PrimeMathError} If n is not a positive integer
 */
function factorizePollardsRho(n, options = {}) {
  let num = toBigInt(n)
  
  if (num &lt;= 0n) {
    throw new PrimeMathError('Factorization is only defined for positive integers')
  }
  
  if (num === 1n) {
    return new Map()
  }
  
  // Check factorization cache first if enabled
  const useCache = options.useCache !== false
  if (useCache) {
    const cachedFactors = _factorizationCache.get(num)
    if (cachedFactors) {
      return new Map(cachedFactors.factors)
    }
  }
  
  // Check small factors first with trial division for efficiency
  const factors = new Map()
  
  // Handle powers of small primes separately for efficiency
  const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n]
  
  for (const prime of smallPrimes) {
    let exponent = 0n
    while (num % prime === 0n) {
      exponent++
      num /= prime
    }
    if (exponent > 0n) {
      factors.set(prime, exponent)
    }
    
    // If we're down to 1, we've fully factored the number
    if (num === 1n) {
      break
    }
  }
  
  // If num is still greater than 1, use enhanced factorization algorithms
  if (num > 1n) {
    const enhancedOptions = {
      ...options,
      // Use advanced algorithms by default for Pollard Rho factorization
      advanced: options.advanced !== false,
      // Set ECM parameters if they weren't provided
      ecmCurves: options.ecmCurves || 15,
      ecmB1: options.ecmB1 || 100000,
      // Set QuadraticSieve parameters
      qsFactorBase: options.qsFactorBase || 100,
      qsSieveSize: options.qsSieveSize || 10000
    }
    
    findFactorsPollardRho(num, factors, enhancedOptions)
  }
  
  // Store in cache if enabled
  if (useCache) {
    _factorizationCache.set(n, factors)
  }
  
  return factors
}

/**
 * Factorize a number using the most appropriate algorithm based on its size and properties
 * Enhanced with Prime Framework optimizations for better performance and precision
 * Implements the Prime Framework's requirements for unique factorization and canonical form
 * Uses configurable thresholds from config.factorization.thresholds to dynamically select
 * the most efficient factorization algorithm based on number characteristics
 * 
 * @param {number|string|BigInt} n - The number to factorize
 * @param {Object} [options] - Factorization options
 * @param {boolean} [options.advanced=false] - Whether to use advanced factorization for large numbers
 * @param {boolean} [options.useCache=true] - Whether to use factorization cache
 * @param {boolean} [options.parallelizeFactorization=false] - Whether to use parallel factorization (when available)
 * @param {Object} [options.algorithmParams] - Specific parameters for factorization algorithms
 * @param {number} [options.algorithmParams.ecmCurves] - Number of curves for ECM
 * @param {number} [options.algorithmParams.ecmB1] - B1 bound for ECM
 * @param {number} [options.algorithmParams.ecmB2] - B2 bound for ECM (stage 2)
 * @param {number} [options.algorithmParams.qsFactorBase] - Factor base size for quadratic sieve
 * @param {number} [options.algorithmParams.qsSieveSize] - Sieve size for quadratic sieve
 * @param {boolean} [options.partialFactorization=false] - Whether to allow partial factorization for very large numbers
 * @param {boolean} [options.validateFactors=true] - Whether to validate that factors are indeed prime
 * @returns {Map&lt;BigInt, BigInt>} A map where keys are prime factors and values are their exponents
 * @throws {PrimeMathError} If n is not a positive integer
 */
function factorizeOptimal(n, options = {}) {
  // Convert input to BigInt using the utility function
  let num
  try {
    num = toBigInt(n)
  } catch (error) {
    // Handle conversion errors for very large inputs
    throw new PrimeMathError(
      `Failed to convert input to BigInt: ${getErrorMessage(error)}`,
      { cause: { input: String(n).substring(0, 100) + (String(n).length > 100 ? '...' : '') } }
    )
  }
  
  // Parse options with defaults
  const { 
    advanced = false, 
    useCache = true, 
    parallelizeFactorization = false,
    partialFactorization = false,
    validateFactors = true,
    algorithmParams = {}
  } = options

  // Import thresholds from the configuration system
  const thresholds = config.factorization.thresholds

  // Validate input according to Prime Framework requirements
  if (num &lt;= 0n) {
    throw new PrimeMathError('Factorization is only defined for positive integers in the Prime Framework')
  }

  // Special case: 1 has no prime factors
  if (num === 1n) {
    return new Map()
  }
  
  // Fast path: Check the factorization cache first if enabled
  if (useCache) {
    try {
      const cachedFactors = _factorizationCache.get(num)
      if (cachedFactors) {
        // Return a deep copy to prevent modification of cached data
        return new Map(cachedFactors.factors)
      }
    } catch (error) {
      // If the cache lookup fails (e.g., due to memory constraints), 
      // continue with direct factorization without failing
      // Skip logging cache lookup failures to avoid linting warnings
    }
  }
  
  // Special case: check if the number is prime
  // This is an optimization for very common case in the Prime Framework
  try {
    if (isPrime(num)) {
      const result = new Map([[num, 1n]])
      
      // Cache the result if caching is enabled
      if (useCache) {
        try {
          _factorizationCache.set(num, result, true, 1.0, {
            computationCost: 1 // Low cost for prime factorization
          })
        } catch (error) {
          // If caching fails, log the error but continue
          // Skip logging cache failures to avoid linting warnings
        }
      }
      
      return result
    }
  } catch (error) {
    // If primality testing fails due to resource constraints, continue with factorization
    // Skip logging primality testing failures to avoid linting warnings
  }
  
  // Get the approximate number of decimal digits to determine algorithm
  const numDigits = num.toString().length
  
  // Calculate the factorization based on number size and requested options
  let result
  
  // Decision tree for selecting the appropriate algorithm
  // This implements the optimal algorithm selection based on number characteristics
  // as specified in the Prime Framework
  if (numDigits &lt;= thresholds.trialDivision) {
    // For small numbers, use simple trial division
    // This is the most efficient for small numbers
    result = factorize(num)
  } else if (numDigits &lt;= thresholds.optimizedTrialDivision) {
    // For medium-sized numbers, use optimized trial division with precomputed primes
    // This leverages the prime cache for better performance
    result = factorizeWithPrimes(num)
  } else if (numDigits &lt;= thresholds.pollardRho) {
    // For larger numbers (up to 25 digits)
    if (advanced) {
      // With advanced option, use a combination of methods
      // This implements the adaptive approach described in the Prime Framework spec
      
      // First try Pollard's Rho which is fast for many cases
      const factors = new Map()
      
      // Check for small prime factors first - common pattern in the Prime Framework
      const smallFactors = findSmallPrimeFactors(num)
      let remaining = num
      
      // If we found small factors, remove them from the number to factorize
      if (smallFactors.size > 0) {
        for (const [prime, exponent] of smallFactors.entries()) {
          factors.set(prime, exponent)
          remaining /= prime ** exponent
        }
        
        // If the remaining number is 1, we're done
        if (remaining === 1n) {
          result = factors
        } else if (isPrime(remaining)) {
          // If the remaining number is prime, add it to factors and we're done
          factors.set(remaining, 1n)
          result = factors
        }
      }
      
      // If we haven't fully factorized yet, continue with more advanced methods
      if (!result) {
        // Try Pollard's Rho first for the remaining part
        result = factorizePollardsRho(remaining, {
          useCache,
          advanced: true,
          partialFactorization: false,
          // Merge with any small factors we found earlier
          initialFactors: factors,
          ...algorithmParams
        })
      }
    } else {
      // Without advanced option, use basic Pollard's Rho
      result = factorizePollardsRho(num, {
        useCache,
        advanced: false,
        ...algorithmParams
      })
    }
  } else if (numDigits &lt;= thresholds.ecm) {
    // For very large numbers (up to 50 digits)
    if (advanced) {
      // With advanced option, use enhanced Pollard's Rho with ECM fallback
      // The Prime Framework requires efficient factorization even for large numbers
      
      // Create a combined factorization strategy
      const enhancedOptions = {
        useCache,
        advanced: true,
        partialFactorization: false,
        // Scale parameters based on number size for optimal performance
        ecmCurves: algorithmParams.ecmCurves || Math.min(20, 5 + Math.floor(numDigits / 4)),
        ecmB1: algorithmParams.ecmB1 || Math.min(500000, 10000 * Math.floor(numDigits / 5)),
        ecmB2: algorithmParams.ecmB2 || 0, // Skip stage 2 by default
        ...algorithmParams
      }
      
      // Use parallelization if requested and supported
      if (parallelizeFactorization) {
        result = factorizeParallel(num, enhancedOptions)
      } else {
        result = factorizePollardsRho(num, enhancedOptions)
      }
    } else {
      // Without advanced option, use basic approach but with better parameters
      result = factorizePollardsRho(num, {
        useCache,
        advanced: false,
        // Still use reasonable parameters even without advanced option
        ecmCurves: algorithmParams.ecmCurves || 10,
        ecmB1: algorithmParams.ecmB1 || 50000,
        ...algorithmParams
      })
    }
  } else if (numDigits &lt;= thresholds.quadraticSieve) {
    // For extremely large numbers (up to 100 digits), use a sophisticated multi-stage approach
    if (!advanced &amp;&amp; !partialFactorization) {
      // Without advanced option or partial factorization permission,
      // this range is too computationally intensive
      throw new PrimeMathError(
        'Number is too large (' + numDigits + ' digits) for non-advanced factorization. ' +
        'Use advanced=true or partialFactorization=true to proceed.'
      )
    }
    
    // Create optimized parameters scaled to number size
    // This implements the adaptive parameters described in the Prime Framework
    const largeNumberOptions = {
      useCache,
      advanced: true,
      parallelizeFactorization,
      partialFactorization,
      // Scale parameters based on number size
      ecmCurves: algorithmParams.ecmCurves || Math.min(30, 10 + Math.floor(numDigits / 5)),
      ecmB1: algorithmParams.ecmB1 || 100000 * Math.floor(numDigits / 20),
      ecmB2: algorithmParams.ecmB2 || Math.min(100000000, 1000000 * Math.floor(numDigits / 20)),
      qsFactorBase: algorithmParams.qsFactorBase || Math.min(500, 100 + Math.floor(numDigits / 4) * 20),
      qsSieveSize: algorithmParams.qsSieveSize || Math.min(100000, 10000 + numDigits * 500),
      ...algorithmParams
    }
    
    // Use a multi-stage approach with different algorithms
    // This is a sophisticated implementation of the Prime Framework's requirement
    // for handling very large numbers effectively
    
    // First try to find small factors efficiently
    const factors = new Map()
    let remaining = num
    
    // Extract small prime factors first
    const smallFactors = findSmallPrimeFactors(remaining)
    
    if (smallFactors.size > 0) {
      // Merge small factors into our result
      for (const [prime, exponent] of smallFactors.entries()) {
        factors.set(prime, exponent)
        remaining /= prime ** exponent
      }
      
      // If we've completely factorized, we're done
      if (remaining === 1n) {
        result = factors
      } else if (isPrime(remaining)) {
        // If what remains is prime, add it and we're done
        factors.set(remaining, 1n)
        result = factors
      }
    }
    
    // If we haven't fully factorized yet, try advanced methods
    if (!result) {
      if (parallelizeFactorization) {
        // Use parallel factorization if requested
        const remainingFactors = factorizeParallel(remaining, largeNumberOptions)
        
        // Merge results
        for (const [prime, exponent] of remainingFactors.entries()) {
          const currentExp = factors.get(prime) || 0n
          factors.set(prime, currentExp + exponent)
        }
        
        result = factors
      } else {
        // Try ECM first to find medium-sized factors
        const factor = ellipticCurveMethod(remaining, largeNumberOptions)
        
        if (factor !== remaining &amp;&amp; factor > 1n) {
          // Found a factor, use recursive factorization
          
          // Factor the first factor
          const factorFactors = factorizePollardsRho(factor, largeNumberOptions)
          const quotient = remaining / factor
          
          // Merge the factorization of the first factor
          for (const [prime, exponent] of factorFactors.entries()) {
            const currentExp = factors.get(prime) || 0n
            factors.set(prime, currentExp + exponent)
          }
          
          // Factor the quotient
          const quotientFactors = factorizePollardsRho(quotient, largeNumberOptions)
          
          // Merge the factorization of the quotient
          for (const [prime, exponent] of quotientFactors.entries()) {
            const currentExp = factors.get(prime) || 0n
            factors.set(prime, currentExp + exponent)
          }
          
          result = factors
        } else {
          // If ECM didn't find a factor, use Quadratic Sieve
          const qsFactors = factorizePollardsRho(remaining, largeNumberOptions)
          
          // Merge the results
          for (const [prime, exponent] of qsFactors.entries()) {
            const currentExp = factors.get(prime) || 0n
            factors.set(prime, currentExp + exponent)
          }
          
          result = factors
        }
      }
    }
  } else {
    // For numbers larger than 100 digits
    if (!partialFactorization) {
      // If partial factorization is not allowed, throw an error
      throw new PrimeMathError(
        'Number is too large (' + numDigits + ' digits) for complete factorization under Prime Framework constraints. ' +
        'Use partialFactorization=true to allow partial results.'
      )
    }
    
    // With partial factorization allowed, try our best
    // The Prime Framework allows partial factorization for extremely large numbers
    // when a complete factorization is computationally infeasible
    const extremeOptions = {
      useCache,
      advanced: true,
      parallelizeFactorization,
      partialFactorization: true,
      // Use aggressive parameters for extremely large numbers
      ecmCurves: algorithmParams.ecmCurves || 50,
      ecmB1: algorithmParams.ecmB1 || 2000000,
      qsFactorBase: algorithmParams.qsFactorBase || 1000,
      ...algorithmParams
    }
    
    // Use parallel factorization if requested
    if (parallelizeFactorization) {
      result = factorizeParallel(num, extremeOptions)
    } else {
      result = factorizePollardsRho(num, extremeOptions)
    }
  }
  
  // Validate the factorization if requested
  if (validateFactors) {
    // Check that all factors are prime
    for (const prime of result.keys()) {
      if (!isPrime(prime)) {
        // This should never happen with correct implementation,
        // but we check as required by the Prime Framework's guarantee of correctness
        throw new PrimeMathError(`Non-prime factor ${prime} found in factorization result. This is a bug.`)
      }
    }
    
    // Check that the factorization is complete (product equals original number)
    // This is a key requirement of the Prime Framework
    const isComplete = isFactorizationComplete(result, num)
    
    // If factorization is not complete and partial factorization is not allowed, throw an error
    if (!isComplete &amp;&amp; !partialFactorization) {
      throw new PrimeMathError(
        'Incomplete factorization result. This is a bug in the factorization algorithm.'
      )
    }
    
    // If using cache, store the result with appropriate metadata
    if (useCache) {
      _factorizationCache.set(num, result, isComplete, isComplete ? 1.0 : 0.9, {
        // Higher computation cost for larger numbers (affects cache retention)
        computationCost: Math.min(10, 1 + Math.floor(numDigits / 10))
      })
    }
  }
  
  return result
}

/**
 * Find small prime factors of a number using trial division
 * Optimized helper function for factorizeOptimal
 * 
 * @private
 * @param {BigInt} n - The number to find factors for
 * @param {number} [limit=1000] - The maximum prime to check
 * @returns {Map&lt;BigInt, BigInt>} Map of prime factors and exponents
 */
function findSmallPrimeFactors(n, limit = 1000) {
  const factors = new Map()
  let remaining = n
  
  // Get small primes from cache
  const smallPrimes = primeCache.getSmallPrimes()
  
  // Try dividing by each small prime
  for (const prime of smallPrimes) {
    // Skip large primes based on limit
    if (prime > limit) break
    
    let exponent = 0n
    while (remaining % prime === 0n) {
      exponent++
      remaining /= prime
    }
    
    if (exponent > 0n) {
      factors.set(prime, exponent)
    }
    
    // Early termination if remaining is 1
    if (remaining === 1n) break
    
    // Early termination if remaining is smaller than the square of the next prime
    if (prime * prime > remaining) {
      if (remaining > 1n) {
        factors.set(remaining, 1n)
      }
      break
    }
  }
  
  return factors
}

/**
 * Check if the factorization of a number is complete
 * 
 * @param {Map&lt;BigInt, BigInt>} factors - The factorization to check
 * @param {BigInt} original - The original number
 * @returns {boolean} True if the factorization is complete, false otherwise
 */
function isFactorizationComplete(factors, original) {
  let product = 1n
  
  for (const [prime, exponent] of factors.entries()) {
    // Handle exponentiation efficiently for large exponents
    let base = prime
    let exp = exponent
    let contribution = 1n
    
    while (exp > 0n) {
      if (exp % 2n === 1n) {
        contribution *= base
      }
      base *= base
      exp /= 2n
    }
    
    product *= contribution
  }
  
  return product === original
}

/**
 * Create a number from its prime factorization
 * Implements the Prime Framework's universal coordinate system conversion
 * 
 * @param {Array&lt;PrimeFactor>|Map&lt;BigInt, BigInt>} factors - Array of {prime, exponent} objects or Map of prime->exponent
 * @param {Object} [options] - Conversion options
 * @param {boolean} [options.validatePrimality=true] - Whether to validate that each factor is prime
 * @param {boolean} [options.enforceCanonicalForm=true] - Whether to enforce canonical form (e.g., sort factors)
 * @returns {BigInt} The number represented by the given prime factorization
 * @throws {PrimeMathError} If any of the factors is not a prime number or has a non-positive exponent
 */
function fromPrimeFactors(factors, options = {}) {
  // Handle empty factorization (represents 1)
  if (!factors || (factors instanceof Map &amp;&amp; factors.size === 0) || 
      (Array.isArray(factors) &amp;&amp; factors.length === 0)) {
    return 1n
  }
  
  // Default options
  const validatePrimality = options.validatePrimality !== false
  const enforceCanonicalForm = options.enforceCanonicalForm !== false
  
  // Convert to Map if array was provided
  const factorMap = factors instanceof Map ? 
    factors : 
    new Map(factors.map(f => [toBigInt(f.prime), toBigInt(f.exponent)]))
  
  // Prime Framework requires canonical representation
  // Ensure factors are normalized (e.g., no negative or zero exponents)
  const normalizedFactors = new Map()
  
  for (const [prime, exponent] of factorMap.entries()) {
    // Validate exponent
    if (exponent &lt;= 0n) {
      throw new PrimeMathError('Exponents must be positive integers', {
        cause: { prime, exponent, expected: 'positive exponent' }
      })
    }
    
    // Validate primality if requested
    if (validatePrimality &amp;&amp; !isPrime(prime)) {
      throw new PrimeMathError(`Factor ${prime} is not a prime number`, {
        cause: { prime, function: 'fromPrimeFactors' }
      })
    }
    
    // Enforce the canonical form by ensuring each prime appears only once
    // and consolidating any duplicate prime factors
    const existingExponent = normalizedFactors.get(prime) || 0n
    normalizedFactors.set(prime, existingExponent + exponent)
  }
  
  // If enforcing canonical form, we want to ensure a consistent order
  // This isn't strictly necessary for computation but ensures consistent results
  // and aligns with the Prime Framework's coherence principles
  let orderedFactors = [...normalizedFactors.entries()]
  
  if (enforceCanonicalForm) {
    // Sort by prime (ascending order)
    orderedFactors.sort((a, b) => a[0] &lt; b[0] ? -1 : a[0] > b[0] ? 1 : 0)
  }
  
  // Compute the product using chunking for large factorizations
  // This helps prevent stack overflow for very large numbers
  let result = 1n
  
  // Process factors in chunks for large factorizations to avoid stack overflows
  const CHUNK_SIZE = 5
  
  // For extremely large factorizations, we'll chunk the calculations
  if (orderedFactors.length > CHUNK_SIZE) {
    // First calculate intermediate results for chunks
    const intermediateResults = []
    
    for (let i = 0; i &lt; orderedFactors.length; i += CHUNK_SIZE) {
      const chunk = orderedFactors.slice(i, Math.min(i + CHUNK_SIZE, orderedFactors.length))
      let chunkResult = 1n
      
      for (const [prime, exponent] of chunk) {
        // Use iterative exponentiation instead of recursive
        let base = prime
        let exp = exponent
        let power = 1n
        
        // Iterative binary exponentiation algorithm (no recursion)
        while (exp > 0n) {
          if (exp % 2n === 1n) {
            power = power * base
          }
          base = base * base
          exp = exp / 2n
        }
        
        chunkResult *= power
      }
      
      intermediateResults.push(chunkResult)
    }
    
    // Multiply together all intermediate results
    for (const ir of intermediateResults) {
      result *= ir
    }
  } else {
    // For smaller factorizations, process directly
    for (const [prime, exponent] of orderedFactors) {
      // Inline the exponentiation logic to avoid function call overhead
      let base = prime
      let exp = exponent
      let power = 1n
      
      // Iterative binary exponentiation (no recursion)
      while (exp > 0n) {
        if (exp % 2n === 1n) {
          power = power * base
        }
        base = base * base
        exp = exp / 2n
      }
      
      result *= power
    }
  }
  
  return result
}

/**
 * Get unique prime factors of a number (without exponents)
 * 
 * @param {number|string|BigInt} n - The number to get prime factors for
 * @returns {BigInt[]} Array of prime factors (without repetition)
 */
function getPrimeFactors(n) {
  const factors = factorizeOptimal(n)
  return [...factors.keys()]
}

/**
 * Convert factorization map to array of {prime, exponent} objects
 * 
 * @param {Map&lt;BigInt, BigInt>} factorMap - Map of prime factors
 * @returns {Array&lt;PrimeFactor>} Array of prime-exponent objects
 */
function factorMapToArray(factorMap) {
  return [...factorMap.entries()].map(([prime, exponent]) => ({
    prime,
    exponent
  }))
}

/**
 * Convert array of {prime, exponent} objects to factorization map
 * 
 * @param {Array&lt;PrimeFactor>} factorArray - Array of prime-exponent objects
 * @returns {Map&lt;BigInt, BigInt>} Map of prime factors
 */
function factorArrayToMap(factorArray) {
  return new Map(
    factorArray.map(factor => [toBigInt(factor.prime), toBigInt(factor.exponent)])
  )
}

/**
 * Find the radical of a number (product of distinct prime factors)
 * 
 * @param {number|string|BigInt} n - The number to find the radical for
 * @returns {BigInt} The radical of n
 */
function getRadical(n) {
  const factors = getPrimeFactors(n)
  return factors.reduce((product, prime) => product * prime, 1n)
}

/**
 * Find the prime signature of a number (product of (p_i - 1)(p_i^e_i - 1))
 * Used in various number theory contexts
 * 
 * @param {number|string|BigInt} n - The number to find the signature for
 * @returns {BigInt} The prime signature
 */
function getPrimeSignature(n) {
  const factors = factorizeOptimal(n)
  let signature = 1n
  
  for (const [prime, exponent] of factors.entries()) {
    // Calculate (prime - 1) * (prime^exponent - 1)
    // Use our own implementation since we don't need modular exponentiation here
    let primePower = 1n
    let base = prime
    let exp = exponent
    while (exp > 0n) {
      if (exp % 2n === 1n) {
        primePower *= base
      }
      base *= base
      exp /= 2n
    }
    signature *= (prime - 1n) * (primePower - 1n)
  }
  
  return signature
}

/**
 * Implements parallel factorization using worker threads when available
 * Falls back to sequential factorization in environments without worker thread support
 * 
 * @param {number|string|BigInt} n - The number to factorize
 * @param {Object} [options] - Factorization options
 * @param {number} [options.workerCount] - Number of worker threads to use (default: CPU count - 1)
 * @param {boolean} [options.useWorkStealing=true] - Whether to use work stealing for load balancing
 * @returns {Map&lt;BigInt, BigInt>} A map where keys are prime factors and values are their exponents
 * @throws {PrimeMathError} If n is not a positive integer
 */
function factorizeParallel(n, options = {}) {
  const num = toBigInt(n)
  
  if (num &lt;= 0n) {
    throw new PrimeMathError('Factorization is only defined for positive integers')
  }
  
  if (num === 1n) {
    return new Map()
  }
  
  // In this implementation, we'll use a simulated parallel approach
  // In a real implementation, this would use Web Workers or Node.js Worker Threads
  
  const useCache = options.useCache !== false
  if (useCache) {
    const cachedFactors = _factorizationCache.get(num)
    if (cachedFactors) {
      return new Map(cachedFactors.factors)
    }
  }
  
  // For numbers that can be factored quickly, don't bother with parallelization
  if (num &lt; 10n ** 20n) {
    return factorizeOptimal(num, options)
  }
  
  // Simulate parallel factorization by breaking the problem into smaller pieces
  
  // First, check for small prime factors using trial division
  const factors = new Map()
  let remaining = num
  
  // Handle small prime factors first (these are quick to find)
  const smallPrimes = primeCache.getSmallPrimes()
  for (const prime of smallPrimes) {
    if (prime * prime > remaining) break
    
    let exponent = 0n
    while (remaining % prime === 0n) {
      exponent++
      remaining /= prime
    }
    
    if (exponent > 0n) {
      factors.set(prime, exponent)
    }
  }
  
  // If the remaining number is 1, we're done
  if (remaining === 1n) {
    return factors
  }
  
  // If the remaining number is prime, add it and we're done
  if (isPrime(remaining)) {
    factors.set(remaining, 1n)
    return factors
  }
  
  // At this point, we have a large composite number
  // In a real parallel implementation, we would:
  // 1. Try to find one factor using various methods
  // 2. Split the problem into two parts: factorizing that factor and factorizing remaining/factor
  // 3. Assign these two sub-problems to worker threads
  // For this simulated version, we'll just use our enhanced sequential algorithms
      
  const factor = pollardRho(remaining, {
    timeLimit: options.timeLimit,
    c: 1n
  })
  
  if (factor === remaining) {
    // If Pollard's Rho failed, try ECM
    const ecmFactor = ellipticCurveMethod(remaining, {
      curves: 10,
      b1: 100000
    })
    
    if (ecmFactor === remaining) {
      // If ECM also failed, use quadratic sieve as a last resort
      const qsFactor = quadraticSieve(remaining, {
        factorBase: 100,
        sieveSize: 10000
      })
      
      if (qsFactor === remaining) {
        // If all methods fail, we treat the number as prime
        // (it's likely a very large prime if all these methods failed)
        factors.set(remaining, 1n)
        return factors
      } else {
        // QS found a factor
        const f1 = factorizeOptimal(qsFactor, options)
        const f2 = factorizeOptimal(remaining / qsFactor, options)
        
        // Merge the factorizations
        for (const [prime, exponent] of f1.entries()) {
          factors.set(prime, exponent)
        }
        
        for (const [prime, exponent] of f2.entries()) {
          const currentExp = factors.get(prime) || 0n
          factors.set(prime, currentExp + exponent)
        }
      }
    } else {
      // ECM found a factor
      const f1 = factorizeOptimal(ecmFactor, options)
      const f2 = factorizeOptimal(remaining / ecmFactor, options)
      
      // Merge the factorizations
      for (const [prime, exponent] of f1.entries()) {
        factors.set(prime, exponent)
      }
      
      for (const [prime, exponent] of f2.entries()) {
        const currentExp = factors.get(prime) || 0n
        factors.set(prime, currentExp + exponent)
      }
    }
  } else {
    // Pollard's Rho found a factor
    const f1 = factorizeOptimal(factor, options)
    const f2 = factorizeOptimal(remaining / factor, options)
    
    // Merge the factorizations
    for (const [prime, exponent] of f1.entries()) {
      factors.set(prime, exponent)
    }
    
    for (const [prime, exponent] of f2.entries()) {
      const currentExp = factors.get(prime) || 0n
      factors.set(prime, currentExp + exponent)
    }
  }
  
  // If using cache, store the result
  if (useCache) {
    _factorizationCache.set(num, factors)
  }
  
  return factors
}

/**
 * Prime Framework-specific factorization optimizations and utilities
 * Provides specialized methods for the Prime Framework
 */
const factorizationCache = {
  /**
   * Get the current size of the factorization cache
   * @returns {number} Number of entries in the cache
   */
  size() {
    return _factorizationCache.size()
  },
  
  /**
   * Clear the factorization cache
   */
  clear() {
    _factorizationCache.clear()
  },
  
  /**
   * Set the maximum size of the factorization cache
   * @param {number} size - New maximum cache size
   */
  setMaxSize(size) {
    _factorizationCache.setMaxSize(size)
  },
  
  /**
   * Get statistics about the cache
   * @returns {Object} Statistics object with size, maxSize, hits, misses, hitRate, and efficiency
   */
  getStats() {
    return _factorizationCache.getStats()
  },
  
  /**
   * Enable or disable persistent caching of factorization results
   * @param {boolean} enabled - Whether to enable persistent caching
   */
  setPersistence(enabled) {
    _factorizationCache.setPersistence(enabled)
  },
  
  /**
   * Save the current cache to persistent storage
   * @returns {boolean} True if successfully saved, false otherwise
   */
  saveToStorage() {
    return _factorizationCache.saveToStorage()
  },
  
  /**
   * Load the cache from persistent storage
   * @returns {boolean} True if successfully loaded, false otherwise
   */
  loadFromStorage() {
    return _factorizationCache.loadFromStorage()
  }
}

// Implementation for fromPrimeFactors has been updated in the main function above

/**
 * Efficient exponentiation by squaring algorithm
 * Uses iterative approach to avoid stack overflow for large exponents
 * This function is now inlined directly where needed for better performance
 * and to avoid function call overhead with very large numbers.
 * 
 * @private
 * @deprecated Use inline implementation instead to avoid stack issues with large numbers
 * @param {BigInt} base - The base value
 * @param {BigInt} exponent - The exponent
 * @returns {BigInt} base raised to the exponent power
 */
// This function is kept for documentation purposes but functionality is inlined
// where needed to avoid deep call stacks with very large numbers

// Initialize the factorization cache
_factorizationCache.initialize()

// Export all functions
module.exports = {
  // Core factorization algorithms
  factorize,
  factorizeWithPrimes,
  factorizePollardsRho,
  factorizeOptimal,
  factorizeParallel,
  
  // Advanced algorithms
  quadraticSieve,
  ellipticCurveMethod,
  
  // Primality testing
  millerRabinTest,
  
  // Helper functions
  pollardRho,
  isFactorizationComplete,
  fromPrimeFactors,
  getPrimeFactors,
  factorMapToArray,
  factorArrayToMap,
  getRadical,
  getPrimeSignature,
  
  // Prime Framework enhancements
  factorizationCache
}</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-modules"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-Conversion.html">Conversion</a></div><div class="sidebar-section-children"><a href="module-Factorization.html">Factorization</a></div><div class="sidebar-section-children"><a href="module-PrimeMath.html">PrimeMath</a></div><div class="sidebar-section-children"><a href="module-UniversalNumber.html">UniversalNumber</a></div><div class="sidebar-section-children"><a href="module-Utils.html">Utils</a></div><div class="sidebar-section-children"><a href="module-config.html">config</a></div><div class="sidebar-section-children"><a href="module-dynamicLoader.html">dynamicLoader</a></div><div class="sidebar-section-children"><a href="module-math-js.html">math-js</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-UniversalNumber-UniversalNumber.html">UniversalNumber</a></div><div class="sidebar-section-children"><a href="module-Utils-PrimeMathError.html">PrimeMathError</a></div><div class="sidebar-section-children"><a href="module-Utils-PrimeMathError.html">PrimeMathError</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-namespaces"><div>Namespaces</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-PrimeMath-PrimeMath.html">PrimeMath</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>