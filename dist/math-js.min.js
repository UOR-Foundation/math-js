!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("PrimeMath",[],n):"object"==typeof exports?exports.PrimeMath=n():t.PrimeMath=n()}(this,(()=>(()=>{var t={44:(t,n,e)=>{const i=e(488),r=e(501),o=e(277),s=e(82),a=e(253),c=e(384),f=e(558);const u=new Map;t.exports={UniversalNumber:i,PrimeMath:r,configure:function(t){return c.configure(t)},config:c.config,resetConfig:c.resetConfig,getConfig:c.getConfig,createStream:function t(n){return{pipe:e=>t((t=>e(n(t)))),map:e=>t((t=>e(n(t)))),filter:e=>t((t=>{const i=n(t);return e(i)?i:null})),process(t){const e=[];for(const i of t){const t=n(i);null!==t&&e.push(t)}return e},reduce(t,e,i){let r=i;for(const i of t){const t=n(i);null!==t&&(r=e(r,t))}return r}}},createAsync:function(t,n={}){const e={...c.config.async,...n};return new Promise(((n,i)=>{let r=!1,o=null;e.defaultTimeout>0&&(o=setTimeout((()=>{r||(r=!0,i(new Error("Operation timed out")))}),e.defaultTimeout));const s=(t,e)=>{r||(r=!0,null!==o&&clearTimeout(o),t?i(t):n(e))};Promise.resolve().then((()=>{try{const n=t();n instanceof Promise?n.then((t=>s(null,t)),(t=>s(t))):s(null,n)}catch(t){s(t)}}))}))},registerPlugin:function(t,n){if("string"!=typeof t||!t)throw new Error("Plugin name must be a non-empty string");if(!n||"object"!=typeof n)throw new Error("Plugin must be an object");if(u.has(t))throw new Error(`Plugin "${t}" is already registered`);u.set(t,n)},getPlugin:function(t){if(!u.has(t))throw new Error(`Plugin "${t}" is not registered`);return u.get(t)},dynamic:f},t.exports.internal={Factorization:o,Conversion:s,Utils:a},t.exports.numberTheory={isPrime:t=>(t instanceof i?t:new i(t)).isIntrinsicPrime(),factorize:t=>(t instanceof i?t:new i(t)).getFactorization(),nextPrime:t=>r.nextPrime(t),gcd:(t,n)=>r.gcd(t,n),lcm:(t,n)=>r.lcm(t,n)},t.exports.crypto={randomPrime:(t,n={})=>r.randomPrime(t,n),modPow:(t,n,e)=>(t instanceof i?t:new i(t)).modPow(n,e),modInverse:(t,n)=>(t instanceof i?t:new i(t)).modInverse(n)},t.exports.analysis={sequence(t,n,e=1){const r=[];for(let o=t;o<=n;o+=e)r.push(new i(o));return r},sum(t){if(!Array.isArray(t)||0===t.length)return new i(1).subtract(new i(1));const n=t[0]instanceof i?t[0]:new i(t[0]);return 1===t.length?n:t.slice(1).reduce(((t,n)=>{const e=n instanceof i?n:new i(n);return t.add(e)}),n)},product(t){if(!Array.isArray(t)||0===t.length)return new i(1);const n=t[0]instanceof i?t[0]:new i(t[0]);return 1===t.length?n:t.slice(1).reduce(((t,n)=>{const e=n instanceof i?n:new i(n);return t.multiply(e)}),n)}}},72:(t,n)=>{n.endianness=function(){return"LE"},n.hostname=function(){return"undefined"!=typeof location?location.hostname:""},n.loadavg=function(){return[]},n.uptime=function(){return 0},n.freemem=function(){return Number.MAX_VALUE},n.totalmem=function(){return Number.MAX_VALUE},n.cpus=function(){return[]},n.type=function(){return"Browser"},n.release=function(){return"undefined"!=typeof navigator?navigator.appVersion:""},n.networkInterfaces=n.getNetworkInterfaces=function(){return{}},n.arch=function(){return"javascript"},n.platform=function(){return"browser"},n.tmpdir=n.tmpDir=function(){return"/tmp"},n.EOL="\n",n.homedir=function(){return"/"}},82:(t,n,e)=>{const{PrimeMathError:i,toBigInt:r}=e(253),{factorizeOptimal:o,fromPrimeFactors:s}=e(277),{config:a}=e(384);function c(t){if(t instanceof Error)try{return t.message}catch(t){return"Error: Could not extract message"}else try{return String(t)}catch(t){return"Unknown error"}}function f(t){const n="0123456789abcdefghijklmnopqrstuvwxyz";if(t<=36)return n.slice(0,t);if(t<=62)return n+"ABCDEFGHIJKLMNOPQRSTUVWXYZ".slice(0,t-36);throw new i(`Base ${t} is supported but needs a custom character set configuration`)}const u=e(488);function l(t,n){if("string"!=typeof t||0===t.length)return!1;let i=0;if(("-"===t[0]||"+"===t[0])&&(i=1,1===t.length))return!1;let r=n;e.g.__EXTENDED_BASE_TEST__&&n>36&&n<=62&&(r=Math.min(n,62));for(let n=i;n<t.length;n++){const e=t[n];let i=!1;if(r<=36){const t=parseInt(e,r);i=!isNaN(t)&&t<r}else if(/[0-9]/.test(e))i=!0;else if(/[a-z]/.test(e)){i=e.charCodeAt(0)-"a".charCodeAt(0)+10<r}else if(/[A-Z]/.test(e)){i=e.charCodeAt(0)-"A".charCodeAt(0)+36<r}if(!i)return!1}return!0}function m(t,n){if(0n===t)return"0";const e=f(n);let i="",r=t;for(;r>0n;){i=e[Number(r%BigInt(n))]+i,r/=BigInt(n)}return i}function h(t,n){return t=t<0n?-t:t,0n===(n=n<0n?-n:n)?t:h(n,t%n)}function g(t){if(!Number.isFinite(t))throw new i("Cannot convert infinite or NaN value to universal coordinates");if(!Number.isSafeInteger(t)&&t!==Math.floor(t))throw new i(`Number ${t} is not a safe integer (exceeds 2^53)`);const n=Math.floor(t),e=n<0;return{factorization:p(BigInt(e?-n:n)),isNegative:e}}function p(t){if(0n===t)return new Map;return o(t<0n?-t:t)}function w(t,n=10){if(!l(t,n))throw new i(`Invalid characters in string for base-${n}: ${t}`);try{const e=t.startsWith("-"),r=e?t.slice(1):t,s=1e4;if(r.length>s)throw new i(`Input string too large (${r.length} chars, max is ${s})`);let a;if(10===n){if(r.length<=1e3)try{a=BigInt(r)}catch(t){a=null}if(null===a||r.length>1e3){a=0n;const t=6;for(let n=0;n<r.length;n+=t){const e=r.slice(n,Math.min(n+t,r.length));if(0===e.length)continue;for(let t=0;t<e.length;t++){const n=parseInt(e[t],10);if(isNaN(n))throw new Error(`Invalid digit '${e[t]}' in base 10 number`)}const i=BigInt(e);if(n>0){a=a*10n**BigInt(e.length)+i}else a=i}}}else if(n<=36){a=0n;const t=BigInt(n);for(let e=0;e<r.length;e++){const i=r[e],o=parseInt(i,n);if(isNaN(o))throw new Error(`Invalid digit '${i}' in base ${n} number`);a=a*t+BigInt(o)}}else{const t=f(n);a=0n;const e=BigInt(n);for(let o=0;o<r.length;o++){const s=r[o];let c=-1;if(c=/[A-Z]/.test(s)?s.charCodeAt(0)-"A".charCodeAt(0)+36:t.indexOf(s.toLowerCase()),-1===c||c>=n)throw new i(`Invalid character '${s}' for base ${n}`);a=a*e+BigInt(c)}}if(0n===a)return{factorization:new Map,isNegative:!1,isZero:!0};return{factorization:o(a),isNegative:e,isZero:!1}}catch(e){if(e instanceof i)throw e;throw new i(`Failed to parse "${t}" in base ${n}: ${c(e)}`)}}function d(t,n=10){if(!(t instanceof Map))throw new i("Factorization must be a Map of prime factors");let{minBase:r,maxBase:o}=a.conversion;if(e.g.__EXTENDED_BASE_TEST__&&n>36&&n<=62&&(o=62),!Number.isInteger(n)||n<r||n>o)throw new i(`Invalid base: ${n} (must be ${r}-${o})`);const c=s(t);return 10===n?c.toString():m(c,n)}function b(t,n={}){const{parallel:e=!1,batchSize:i=100,preserveFactorization:r=!0,streamingOutput:o=!1}=n;function s(n){let i=[...n];for(const n of t)i=(e&&n.options&&n.options.parallelizable,i.map((t=>n.process(t,n.options)))),r&&"format"===n.type&&n.options&&n.options.maintainFactorization&&(i=i.map((t=>t&&"object"==typeof t&&"originalFactorization"in t?{...t,factorization:t.originalFactorization}:t)));return i}return(t,n)=>function(t,n){if(t.length>i){const e=[];for(let n=0;n<t.length;n+=i)e.push(t.slice(n,n+i));if(o&&n)return void e.forEach((t=>{s(t).forEach((t=>n(t)))}));{const t=[];return e.forEach((n=>{t.push(...s(n))})),t}}{const e=s(t);return o&&n?void e.forEach((t=>n(t))):e}}(t,n)}function v(t={}){return{type:"transform",options:{...t,maintainFactorization:!0},process:t=>{let n,e=!1;if(t instanceof Map)n=t;else if(t&&"object"==typeof t&&"factorization"in t)n=t.factorization,e=!!t.isNegative;else if("string"==typeof t){const i=w(t);n=i.factorization,e=i.isNegative}else if("number"==typeof t){const i=g(t);n=i.factorization,e=i.isNegative}else{if("bigint"!=typeof t)throw new i("Unsupported value type: "+typeof t);e=t<0n,n=p(e?-t:t)}return{factorization:new Map(n),originalFactorization:new Map(n),isNegative:e,originalValue:t}}}}function y(t,n={}){return{type:"format",options:{toBase:t,...n,maintainFactorization:!0,parallelizable:!0},process:(t,n)=>{const{toBase:e}=n;let o,s=!1;if(t&&"object"==typeof t&&("factorization"in t?(o=t.factorization,s=!!t.isNegative):t instanceof Map&&(o=t)),o){const t=d(o,e);return s?"-"+t:t}try{const n=r(t),i=m(n<0n?-n:n,e);return n<0n?"-"+i:i}catch(t){throw new i(`Failed to convert value to base ${e}: ${c(t)}`)}}}}function z(t){if(t<=1n)return!1;if(t<=3n)return!0;if(t%2n===0n||t%3n===0n)return!1;let n=5n;for(;n*n<=t;){if(t%n===0n||t%(n+2n)===0n)return!1;n+=6n}return!0}function S(t={}){const{id:n="canonical",parameters:e={}}=t;return{id:n,parameters:e instanceof Map?e:new Map(Object.entries(e)),getCliffAlgebra:()=>({gradeStructure:new Map([[0,{dimension:1,description:"Scalar part"}],[1,{dimension:1/0,description:"Vector part - corresponds to prime powers"}]]),product(t,n){if(t instanceof Map&&n instanceof Map){const e=new Map(t);for(const[t,i]of n.entries()){const n=e.get(t)||0n;e.set(t,n+i)}return e}throw new i("Invalid inputs for Clifford product")}}),transform(t,n){let e,r=!1;if(t instanceof Map)e=t;else{if(!t||"object"!=typeof t||!("factorization"in t))throw new i("Invalid coordinates format");e=t.factorization,r=!!t.isNegative}for(const[t,n]of e.entries()){if(n<=0n)throw new i("Coordinates must be in canonical form for transformation");if(t<=1000n&&!z(t))throw new i(`Factor ${t} is not a valid prime number`)}const o=new Map(e);return t instanceof Map?o:{factorization:o,isNegative:r}}}}const N=S({id:"canonical"});function M(t,n,e={}){e.referenceFrame;let r,o;if(t instanceof Map)r=t;else{if(!t||"object"!=typeof t||!("factorization"in t))throw new i("Invalid coordinates format for first argument");r=t.factorization}if(n instanceof Map)o=n;else{if(!n||"object"!=typeof n||!("factorization"in n))throw new i("Invalid coordinates format for second argument");o=n.factorization}const s=new Set([...r.keys(),...o.keys()]);let a=0n;for(const t of s){a+=(r.get(t)||0n)*(o.get(t)||0n)}return a}function _(t,n={}){n.referenceFrame;let e;if(t instanceof Map)e=t;else{if(!t||"object"!=typeof t||!("factorization"in t))throw new i("Invalid coordinates format");e=t.factorization}for(const[t,n]of e.entries()){if(n<=0n)return!1;if(t<=1000n){if(!z(t))return!1}else{const n=(t,n=5)=>{if(t<=1n)return!1;if(t<=3n)return!0;if(t%2n===0n)return!1;let i=0n,r=t-1n;for(;r%2n===0n;)r/=2n,i++;const o=n;for(let n=0;n<o;n++){const n=2n+BigInt(Math.floor(Math.random()*Number(t-4n)));let o=e(n,r,t);if(1n===o||o===t-1n)continue;let s=!1;for(let n=0n;n<i-1n;n++)if(o=o*o%t,o===t-1n){s=!0;break}if(!s)return!1}return!0},e=(t,n,e)=>{if(1n===e)return 0n;let i=1n,r=t%e,o=n;for(;o>0n;)o%2n===1n&&(i=i*r%e),o>>=1n,r=r*r%e;return i};if(!n(t))return!1}}const r=[...e.keys()];for(let t=0;t<r.length;t++)for(let n=t+1;n<r.length;n++){if(h(r[t],r[n])>1n)return!1}if(e.size>0){const t=[...e.entries()].sort(((t,n)=>t[0]<n[0]?-1:t[0]>n[0]?1:0));for(const[n,e]of t);}return!0}const I={convertBase:function(t,n=10,o=10){let s=36;if(e.g.__EXTENDED_BASE_TEST__&&(s=62),!Number.isInteger(n)||n<2||n>s)throw new i(`Invalid fromBase: ${n} (must be 2-${s})`);if(!Number.isInteger(o)||o<2||o>s)throw new i(`Invalid toBase: ${o} (must be 2-${s})`);if("string"==typeof t){if(!l(t,n))throw new i(`Invalid characters in string for base-${n}: ${t}`);try{const e=t.startsWith("-"),i=e?t.slice(1):t;let r;r=10===n?BigInt(i):[...i].reduce(((t,e)=>{const i=parseInt(e,n);return t*BigInt(n)+BigInt(i)}),0n);return 10===o?(e?-r:r).toString():(e?"-":"")+m(r,o)}catch(e){throw new i(`Failed to convert ${t} from base-${n} to base-${o}: ${c(e)}`)}}try{const n=r(t),e=n<0n,i=e?-n:n;return 10===o?n.toString():(e?"-":"")+m(i,o)}catch(n){if(n instanceof i)throw n;throw new i(`Failed to convert ${t} to base-${o}: ${c(n)}`)}},getDigits:function(t,n=10,o=!1){let{minBase:s,maxBase:f}=a.conversion;if(e.g.__EXTENDED_BASE_TEST__&&n>36&&n<=62&&(f=62),!Number.isInteger(n)||n<s||n>f)throw new i(`Invalid base: ${n} (must be ${s}-${f})`);try{const e=r(t),i=e<0n?-e:e;if(0n===i)return[0];const s=[];let a=i;for(;a>0n;){const t=Number(a%BigInt(n));s.push(t),a/=BigInt(n)}return o?s:s.reverse()}catch(n){if(n instanceof i)throw n;throw new i(`Failed to extract digits from ${t}: ${c(n)}`)}},fromNumber:g,fromBigInt:p,fromString:w,toBigInt:function(t){if(!(t instanceof Map))throw new i("Factorization must be a Map of prime factors");return s(t)},toString:d,getDigitsFromValue:function(t,n=10,o={}){const{leastSignificantFirst:f=!1,includeSign:u=!1}=o;let l,{minBase:m,maxBase:h}=a.conversion;if(e.g.__EXTENDED_BASE_TEST__&&n>36&&n<=62&&(h=62),!Number.isInteger(n)||n<m||n>h)throw new i(`Invalid base: ${n} (must be ${m}-${h})`);let g=!1;if(t instanceof Map)l=s(t);else if(t&&"object"==typeof t&&"factorization"in t){if(!(t.factorization instanceof Map))throw new i("Invalid factorization format");l=s(t.factorization),g=!!t.isNegative,g&&(l=-l)}else try{l=r(t)}catch(t){throw new i(`Cannot extract digits: ${c(t)}`)}if(l<0n&&(g=!0,l=-l),0n===l){const t={digits:[0]};return u&&(t.isNegative=!1),t}const p=[];let w=l;for(;w>0n;){const t=Number(w%BigInt(n));p.push(t),w/=BigInt(n)}const d={digits:f?p:p.reverse()};return u&&(d.isNegative=g),d},convertBaseViaUniversal:function(t,n,e,r={}){const{useFactorizationShortcuts:o=!0,useDirectComputation:a=!0}=r;if(!Number.isInteger(n)||n<2||n>36)throw new i(`Invalid fromBase: ${n} (must be 2-36)`);if(!Number.isInteger(e)||e<2||e>36)throw new i(`Invalid toBase: ${e} (must be 2-36)`);if(n===e){if("string"==typeof t)return t;if("number"==typeof t)return t.toString(e);if("bigint"==typeof t)return t.toString(e);if(t instanceof Map){return m(s(t),e)}}if(t instanceof Map){return m(s(t),e)}if(o){const i=function(t,n,e){if(2===n&&16===e&&"string"==typeof t){let n=t;const e=n.startsWith("-");e&&(n=n.substring(1));const i=(4-n.length%4)%4;n="0".repeat(i)+n;let r="";for(let t=0;t<n.length;t+=4){const e=n.substring(t,t+4);r+=parseInt(e,2).toString(16).toLowerCase()}return r=r.replace(/^0+(?=\S)/,""),e?"-"+r:r}if(16===n&&2===e&&"string"==typeof t){let n=t;const e=n.startsWith("-");e&&(n=n.substring(1));let i="";for(let t=0;t<n.length;t++){i+=parseInt(n[t],16).toString(2).padStart(4,"0")}return i=i.replace(/^0+(?=\S)/,""),""===i&&(i="0"),e?"-"+i:i}if(2===n&&8===e&&"string"==typeof t){let n=t;const e=n.startsWith("-");e&&(n=n.substring(1));const i=(3-n.length%3)%3;n="0".repeat(i)+n;let r="";for(let t=0;t<n.length;t+=3){const e=n.substring(t,t+3);r+=parseInt(e,2).toString(8)}return r=r.replace(/^0+(?=\S)/,""),""===r&&(r="0"),e?"-"+r:r}if(8===n&&2===e&&"string"==typeof t){let n=t;const e=n.startsWith("-");e&&(n=n.substring(1));let i="";for(let t=0;t<n.length;t++){i+=parseInt(n[t],8).toString(2).padStart(3,"0")}return i=i.replace(/^0+(?=\S)/,""),""===i&&(i="0"),e?"-"+i:i}if(10===n&&(2===e||8===e||16===e)){if("number"==typeof t&&Number.isInteger(t)&&Number.isSafeInteger(t))return Math.abs(t).toString(e);if("string"==typeof t)try{const n=Number(t);if(Number.isInteger(n)&&Number.isSafeInteger(n)){const i=Math.abs(n).toString(e);return t.startsWith("-")?"-"+i:i}}catch(t){}}return null}(t,n,e);if(null!==i)return i}let c,f=!1;if("string"==typeof t){const e=w(t,n);f=e.isNegative,c=e.factorization}else if("number"==typeof t){const n=g(t);f=n.isNegative,c=n.factorization}else{if("bigint"!=typeof t)throw new i("Unsupported value type: "+typeof t);f=t<0n,c=p(f?-t:t)}if(a){const t=function(t,n){if(!(n&n-1)&&n>0){if(1===t.size&&t.has(2n)){const e=t.get(2n);if(2===n)return"1"+"0".repeat(Number(e));const i=Math.log2(n),r=Math.floor(Number(e)/i),o=Number(e)%i;let s="";return o>0&&(s+=(1<<o).toString(n)),r>0&&(s+="0".repeat(r)),s}if(t.size<=3){let e=1n;for(const[n,i]of t.entries()){if(n>1000n)return null;e*=n**i}return e.toString(n)}}if(n>2){let e=null,i=0;for(let t=2;t<=Math.sqrt(n);t++)if(n%t==0){let r=0,o=n;for(;o%t==0;)o/=t,r++;if(1===o){e=BigInt(t),i=r;break}}if(null!==e&&1===t.size&&t.has(e)){const n=t.get(e),r=Number(n)/i,o=Math.floor(r);let s="";return s+=Number(n)%i>0?e.toString():"1",o>0&&(s+="0".repeat(o)),s}}return null}(c,e);if(null!==t)return f?"-"+t:t}const u=s(c);return f?"-"+m(u,e):m(u,e)},toScientificNotation:function(t,n=6){try{if("number"==typeof t&&Number.isFinite(t))return t.toExponential(n);try{const e=r(t),i=e<0n,o=(i?-e:e).toString();if(1===o.length)return(i?"-":"")+o+".0e+0";const s=o[0],a=o.length-1;let c="";return o.length>1?(c=o.substring(1,Math.min(n+1,o.length)),c.length<n&&(c=c.padEnd(n,"0"))):c="0".repeat(n),(i?"-":"")+`${s}.${c}e+${a}`}catch(e){if("string"==typeof t&&t.includes(".")){const e=parseFloat(t);if(!isNaN(e))return e.toExponential(n)}throw e}}catch(n){if(n instanceof i)throw n;throw new i(`Failed to convert ${t} to scientific notation: ${c(n)}`)}},toFraction:function t(n){if("bigint"==typeof n)return{numerator:n,denominator:1n};if("number"==typeof n){if(!Number.isFinite(n))throw new i("Cannot convert infinite or NaN value to fraction");const t=n<0,e=Math.abs(n).toString(),r=e.indexOf(".");if(-1===r)return{numerator:t?-BigInt(e):BigInt(e),denominator:1n};const o=e.substring(0,r)||"0",s=e.substring(r+1);if(0===s.length)return{numerator:t?-BigInt(o):BigInt(o),denominator:1n};const a=BigInt(o+s),c=10n**BigInt(s.length),f=h(a,c);return{numerator:t?-a/f:a/f,denominator:c/f}}try{if("string"==typeof n){if(n.includes(".")){const e=parseFloat(n);if(isNaN(e))throw new i(`Invalid decimal string: ${n}`);return t(e)}return{numerator:r(n),denominator:1n}}return t(String(n))}catch(t){if(t instanceof i)throw t;throw new i(`Failed to convert ${n} to fraction: ${c(t)}`)}},factorizationToString:function(t){let n,e=!1;if(t&&"object"==typeof t&&"factorization"in t)n=t.factorization,e=!!t.isNegative;else{if(!(t instanceof Map))throw new i("Invalid factorization format");n=t}if(0===n.size)return e?"-1":"1";const r=[],o=[...n.entries()].sort(((t,n)=>t[0]<n[0]?-1:t[0]>n[0]?1:0));for(const[t,n]of o)1n===n?r.push(`${t}`):r.push(`${t}^${n}`);const s=r.join(" × ");return e?"-("+s+")":s},parseFactorization:function(t,n={}){const{withSignFlag:e=!1}=n;try{const n=t.trim().startsWith("-");let i=t.trim();if(n&&(i=i.substring(1).trim(),i.startsWith("(")&&i.endsWith(")")&&(i=i.substring(1,i.length-1).trim())),"1"===i){const t=new Map;return e?{factorization:t,isNegative:n}:t}const o=i.replace(/\s+/g,""),s=new Map;if(o.includes("×")||o.includes("*")){const t=o.split(/[×*]/);for(const n of t)if(n.includes("^")){const[t,e]=n.split("^"),i=r(t),o=r(e),a=s.get(i)||0n;s.set(i,a+o)}else if(n){const t=r(n),e=s.get(t)||0n;s.set(t,e+1n)}}else if(o.includes("^")){const[t,n]=o.split("^"),e=r(t),i=r(n);s.set(e,i)}else if(o.includes("·")){const t=o.split("·");for(const n of t)if(n){const t=r(n),e=s.get(t)||0n;s.set(t,e+1n)}}else{const t=r(o);t>1n&&s.set(t,1n)}return e?{factorization:s,isNegative:n}:s}catch(n){throw new i(`Invalid factorization string: ${t}`)}},toJSON:function(t,n={}){const{value:e,isFactorization:r=!1}=t,{format:o="standard",includeMetadata:s=!1}=n;try{if(r){const t={};if(!(e instanceof Map))throw new i("Value is not a valid factorization Map");if("standard"===o){for(const[n,i]of e.entries()){t[n.toString()]=i.toString()}const n={type:"Factorization",factors:t};return s&&(n.metadata={format:"standard",primeCount:e.size,timestamp:(new Date).toISOString()}),JSON.stringify(n)}if("compact"===o){const t=[...e.entries()].sort((([t],[n])=>t<n?-1:t>n?1:0)),n=[],i=[];for(const[e,r]of t)n.push(e.toString()),i.push(r.toString());const r={type:"CompactFactorization",primes:n,exponents:i};return s&&(r.metadata={format:"compact",primeCount:n.length,timestamp:(new Date).toISOString()}),JSON.stringify(r)}if("binary"===o){const t=[...e.entries()].sort((([t],[n])=>t<n?-1:t>n?1:0)),n=[],i=[];for(const[e,r]of t)n.push(e.toString()),i.push(r.toString());const r=JSON.stringify({p:n,e:i});let o;try{if("undefined"!=typeof Buffer){o=Buffer.from(r,"utf8").toString("base64")}else o=btoa(unescape(encodeURIComponent(r)))}catch(t){o=JSON.stringify(r)}const a={type:"BinaryFactorization",encoding:"base64",data:o};return s&&(a.metadata={format:"binary",primeCount:n.length,timestamp:(new Date).toISOString()}),JSON.stringify(a)}if("streaming"===o){const t=100,n=[...e.entries()].sort((([t],[n])=>t<n?-1:t>n?1:0)),i=[];let r={primes:[],exponents:[]},o=0;for(const[e,s]of n)r.primes.push(e.toString()),r.exponents.push(s.toString()),o++,o%t==0&&(i.push(r),r={primes:[],exponents:[]});r.primes.length>0&&i.push(r);const a={type:"StreamingFactorization",chunkCount:i.length,chunks:i};return s&&(a.metadata={format:"streaming",primeCount:n.length,timestamp:(new Date).toISOString()}),JSON.stringify(a)}throw new i(`Unsupported serialization format: ${o}`)}{if("bigint"!=typeof e)throw new i("Value is not a valid BigInt");const t={type:"BigInt",value:e.toString()};return s&&(t.metadata={format:o,digits:e.toString().length,timestamp:(new Date).toISOString()}),JSON.stringify(t)}}catch(t){throw new i(`Failed to serialize to JSON: ${c(t)}`)}},fromJSON:function(t,n={}){const{validateMetadata:e=!1}=n;try{const n=JSON.parse(t);if(!n.type)throw new Error("Missing type field");let i=null;if(e&&n.metadata&&(i=n.metadata,i.timestamp)){const t=new Date(i.timestamp);if(isNaN(t.getTime()))throw new Error("Invalid timestamp in metadata")}if("BigInt"===n.type){const t={value:r(n.value),isFactorization:!1};return i&&(t.metadata=i),t}if("Factorization"===n.type){if(!n.factors)throw new Error("Missing factors field");const t=new Map;for(const[e,i]of Object.entries(n.factors))t.set(r(e),r(i));const e={value:t,isFactorization:!0};return i&&(e.metadata=i),e}if("CompactFactorization"===n.type){if(!(n.primes&&n.exponents&&Array.isArray(n.primes)&&Array.isArray(n.exponents)))throw new Error("Invalid CompactFactorization format");if(n.primes.length!==n.exponents.length)throw new Error("Primes and exponents arrays must have the same length");const t=new Map;for(let e=0;e<n.primes.length;e++){const i=r(n.primes[e]),o=r(n.exponents[e]);t.set(i,o)}const e={value:t,isFactorization:!0};return i&&(e.metadata=i),e}if("BinaryFactorization"===n.type){if(!n.encoding||!n.data)throw new Error("Invalid BinaryFactorization format");let t;try{let e;if("undefined"!=typeof Buffer){e=Buffer.from(n.data,"base64").toString("utf8")}else e=decodeURIComponent(escape(atob(n.data)));t=JSON.parse(e)}catch(t){throw t instanceof Error?new Error(`Failed to decode binary data: ${t.message}`):new Error(`Failed to decode binary data: ${String(t)}`)}if(!(t.p&&t.e&&Array.isArray(t.p)&&Array.isArray(t.e)))throw new Error("Invalid binary data format");const e=new Map;for(let n=0;n<t.p.length;n++){const i=r(t.p[n]),o=r(t.e[n]);e.set(i,o)}const o={value:e,isFactorization:!0};return i&&(o.metadata=i),o}if("StreamingFactorization"===n.type){if(!n.chunks||!Array.isArray(n.chunks))throw new Error("Invalid StreamingFactorization format");const t=new Map;for(const e of n.chunks){if(!(e.primes&&e.exponents&&Array.isArray(e.primes)&&Array.isArray(e.exponents)&&e.primes.length===e.exponents.length))throw new Error("Invalid chunk format in StreamingFactorization");for(let n=0;n<e.primes.length;n++){const i=r(e.primes[n]),o=r(e.exponents[n]);t.set(i,o)}}const e={value:t,isFactorization:!0};return i&&(e.metadata=i),e}throw new Error(`Unknown type: ${n.type}`)}catch(t){throw new i(`Failed to parse JSON: ${c(t)}`)}},createReferenceFrame:S,canonicalFrame:N,coherenceInnerProduct:M,coherenceNorm:function(t,n={}){return M(t,t,n)},isCanonicalForm:_,transformCoordinates:(t,n,e)=>n.transform(t,e),createConversionPipeline:b,convertToUniversalStep:v,baseConversionStep:y,batchConvertBase(t,n,e,i={}){const{parallel:r=!1,useFactorization:o=!0}=i;return b([v(),y(e)],{parallel:r,batchSize:100,preserveFactorization:o})(t)},streamConvertBase(t,n,e,i,r={}){const{parallel:o=!1,useFactorization:s=!0}=r;b([v(),y(e)],{parallel:o,batchSize:100,preserveFactorization:s,streamingOutput:!0})(t,i)},fromFactorization(t){let n,e=!1;return t&&"object"==typeof t&&"factorization"in t?(n=s(t.factorization),e=!!t.isNegative):n=s(t),e?-n:n},toFactorization(t,n={}){const{withSignFlag:e=!1,validatePrimality:r=!0,enforceCanonical:s=!0,...a}=n;let c=!1,f=t;if("number"==typeof t){if(!Number.isFinite(t))throw new i("Cannot factorize infinite or NaN values");c=t<0,f=Math.abs(t)}else if("bigint"==typeof t)c=t<0n,f=t<0n?-t:t;else{if("string"!=typeof t)throw new i("Unsupported value type for factorization: "+typeof t);c=t.startsWith("-"),f=c?t.substring(1):t}if("number"==typeof f&&0===f||"string"==typeof f&&/^0+$/.test(f)||"bigint"==typeof f&&0n===f)throw new i("Universal coordinates are only defined for non-zero integers");const u=o(f,a);if(r)for(const[t,n]of u.entries()){if(n<=0n)throw new i(`Invalid exponent ${n} for prime ${t}`);if(t<=1000n){if(!z(t))throw new i(`Factor ${t} is not a valid prime number`)}else{const n=(t,n=7)=>{if(t<=1n)return!1;if(t<=3n)return!0;if(t%2n===0n)return!1;let i=0n,r=t-1n;for(;r%2n===0n;)r/=2n,i++;for(let o=0;o<n;o++){const n=2n+BigInt(Math.floor(Math.random()*Number(t-4n<Number.MAX_SAFE_INTEGER?t-4n:Number.MAX_SAFE_INTEGER)));let o=e(n,r,t);if(1n===o||o===t-1n)continue;let s=!1;for(let n=0n;n<i-1n;n++)if(o=o*o%t,o===t-1n){s=!0;break}if(!s)return!1}return!0},e=(t,n,e)=>{if(1n===e)return 0n;let i=1n,r=t%e,o=n;for(;o>0n;)o%2n===1n&&(i=i*r%e),o>>=1n,r=r*r%e;return i};if(!n(t))throw new i(`Factor ${t} is not a valid prime number`)}}if(s){if(!_(e?{factorization:u,isNegative:c}:u)){const t=[...u.entries()].sort((([t],[n])=>t<n?-1:t>n?1:0)),n=new Map(t);return e?{factorization:n,isNegative:c}:n}}return e?{factorization:u,isNegative:c}:u},createUniversalNumber(t){let n,e=!1;if(t instanceof Map)n=t;else{if(!t||"object"!=typeof t||!("factorization"in t))throw new i("Invalid factorization format");n=t.factorization,e=!!t.isNegative}for(const[t,e]of n.entries()){if(e<=0n)throw new i(`Invalid exponent ${e} for prime ${t}`);if(t<=1000n&&!z(t))throw new i(`Factor ${t} is not a valid prime number`)}if(!_(t)){const t=[...n.entries()].sort((([t],[n])=>t<n?-1:t>n?1:0));n=new Map(t)}const r=new Map(n);return new u({factorization:r,isNegative:e})},_validateBase(t={}){const{base:n=10,validate:r=!0}=t;if(r){let{minBase:t,maxBase:r}=a.conversion;if(e.g.__EXTENDED_BASE_TEST__&&n>36&&n<=62&&(r=62),!Number.isInteger(n)||n<t||n>r)throw new i(`Invalid base: ${n} (must be ${t}-${r})`)}return n}};I.validateStringForBase=l,I.getDigitCharset=f,t.exports=I},253:(t,n,e)=>{const{config:i}=e(384);class r extends Error{constructor(t){super(t),this.name="PrimeMathError",i.errorHandling&&!i.errorHandling.includeStackTrace&&(this.stack=void 0)}}const o={knownPrimes:[2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n,41n,43n,47n,53n,59n,61n,67n,71n,73n,79n,83n,89n,97n,101n,103n,107n,109n,113n,127n,131n,137n,139n,149n,151n,157n,163n,167n,173n,179n,181n,191n,193n,197n,199n,211n,223n,227n,229n,233n,239n,241n,251n,257n,263n,269n,271n,277n,281n,283n,293n,307n,311n,313n,317n,331n,337n,347n,349n,353n,359n,367n,373n,379n,383n,389n,397n,401n,409n,419n,421n,431n,433n,439n,443n,449n,457n,461n,463n,467n,479n,487n,491n,499n,503n,509n,521n,523n,541n,547n,557n,563n,569n,571n,577n,587n,593n,599n,601n,607n,613n,617n,619n,631n,641n,643n,647n,653n,659n,661n,673n,677n,683n,691n,701n,709n,719n,727n,733n,739n,743n,751n,757n,761n,769n,773n,787n,797n,809n,811n,821n,823n,827n,829n,839n,853n,857n,859n,863n,877n,881n,883n,887n,907n,911n,919n,929n,937n,941n,947n,953n,967n,971n,977n,983n,991n,997n],primalityMap:new Map,largestKnownPrime:997n,largestCheckedNumber:997n,get MAX_CACHE_SIZE(){return i.cache.maxPrimeCacheSize},initialize(){this.knownPrimes.forEach((t=>{this.primalityMap.set(t.toString(),!0)})),this.primalityMap.set("0",!1),this.primalityMap.set("1",!1)}};function s(t,n,e=null){if(n<0n)throw new r("Exponent must be non-negative in the Prime Framework");if(0n===n)return 1n;if(0n===t)return 0n;if(1n===t)return 1n;if(-1n===t)return n%2n===0n?1n:-1n;if(null!==e&&(t%=e),null!==e){let i=1n,r=t,o=n;for(;o>0n;)o%2n===1n&&(i=i*r%e),r=r*r%e,o/=2n;return i}{if(n>1000n&&(t>10n||t<-10n))throw new r("Exponentiation may exceed safe BigInt range. Use modular exponentiation instead.",{cause:{base:t,exponent:n}});let e=1n,i=t,o=n;for(;o>0n;){if(o%2n===1n&&(e*=i),o>1n&&i>Number.MAX_SAFE_INTEGER&&e>Number.MAX_SAFE_INTEGER)throw new r("Exponentiation result exceeds safe computation range",{cause:{base:t,exponent:n,currentExponent:o}});i*=i,o/=2n}return e}}function a(t,n){if(0n===n)throw new r("Division by zero is not allowed in the Prime Framework");return t%n===0n}function c(t,n){if(n=n<0n?-n:n,0n===(t=t<0n?-t:t))return n;if(0n===n)return t;if(t===n)return t;if(1n===t||1n===n)return 1n;let e=0n;for(;0n===(1n&(t|n));)t>>=1n,n>>=1n,e++;for(;0n===(1n&t);)t>>=1n;for(;0n!==n;){for(;0n===(1n&n);)n>>=1n;t>n&&([t,n]=[n,t]),n-=t}return t<<e}function f(t){try{if(null==t)throw new r("Cannot convert null or undefined to BigInt");if("number"==typeof t){if(!Number.isFinite(t))throw new r("Cannot convert infinite or NaN value to BigInt");if(!Number.isInteger(t))throw new r("Cannot convert non-integer number to BigInt (Prime Framework requires integers)");if(!Number.isSafeInteger(t))throw new r("Number exceeds safe integer range, use string input for large values")}if("string"==typeof t&&(t=t.trim(),!/^[+-]?\d+$/.test(t)))throw new r("String must contain a valid integer number");return BigInt(t)}catch(t){if(t instanceof r)throw t;const n=t instanceof Error?t.message:String(t);throw new r(`Cannot convert value to BigInt: ${n}`)}}function u(t,n={useCache:!0,updateCache:!0}){const e=!1!==n.useCache,a=!1!==n.updateCache;if("bigint"!=typeof t)try{t=f(t)}catch(t){return!1}if(t<=1n)return!1;if(e){const n=o.primalityMap.get(t.toString());if(void 0!==n)return n}if(t<10000n){if(t<=3n)return!0;if(t%2n===0n||t%3n===0n)return!1;let n=5n;for(;n*n<=t;){if(t%n===0n||t%(n+2n)===0n)return e&&a&&(o.primalityMap.set(t.toString(),!1),o.primalityMap.size>o.MAX_CACHE_SIZE&&l()),!1;n+=6n}return e&&a&&(o.primalityMap.set(t.toString(),!0),t>o.largestKnownPrime&&(o.largestKnownPrime=t),t>o.largestCheckedNumber&&(o.largestCheckedNumber=t)),!0}const c=function(t,n=null){if(null===n&&(n=i.primalityTesting.millerRabinRounds),t<=1n)return!1;if(t<=3n)return!0;if(t%2n===0n)return!1;let e=0n,a=t-1n;for(;a%2n===0n;)a/=2n,e+=1n;const c=t<2n**64n;if(t>2n**100n){for(const n of o.knownPrimes){if(n*n>t)break;if(t%n===0n)return!1}n=Math.min(n,5)}const f=n=>{let i=s(n,a,t);if(1n===i||i===t-1n)return!0;for(let n=1n;n<e;n++){if(i=i*i%t,i===t-1n)return!0;if(1n===i)return!1}return!1};if(c){const n=[2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n];for(const e of n){if(e>=t)break;if(!f(e))return!1}return!0}for(let e=0;e<n;e++){const n=[2,3,5,7,11,13,17,19,23,29,31,37],i=BigInt(n[e%n.length])%(t-3n)+2n;try{if(!f(i))return!1}catch(n){if(n instanceof r)return u(t,{useCache:!1,updateCache:!1});throw n}}return!0}(t);return e&&a&&(o.primalityMap.set(t.toString(),c),c&&t>o.largestKnownPrime&&(o.largestKnownPrime=t),t>o.largestCheckedNumber&&(o.largestCheckedNumber=t),o.primalityMap.size>o.MAX_CACHE_SIZE&&l()),c}function l(){const t=Math.floor(.8*o.MAX_CACHE_SIZE);if(o.primalityMap.size<=1.1*o.MAX_CACHE_SIZE)return;const n=[];for(const t of o.primalityMap.keys()){BigInt(t)>1000n&&n.push(t)}const e=Math.max(o.primalityMap.size-t,Math.floor(.5*n.length));n.sort(((t,n)=>{const e=o.primalityMap.get(t);if(e!==o.primalityMap.get(n))return e?1:-1;const i=BigInt(t),r=BigInt(n);return i>r?-1:i<r?1:0}));const i=n.slice(0,e);for(const t of i)o.primalityMap.delete(t);if(!1===o.primalityMap.has(o.largestKnownPrime.toString())){let t=o.knownPrimes[o.knownPrimes.length-1];for(const[n,e]of o.primalityMap.entries())if(e){const e=BigInt(n);e>t&&(t=e)}o.largestKnownPrime=t}}function m(t){if((t=f(t))<=BigInt(Number.MAX_SAFE_INTEGER)){const n=Number(t),e=new Array(n+1).fill(!0);e[0]=e[1]=!1;for(let t=2;t*t<=n;t++)if(e[t])for(let i=t*t;i<=n;i+=t)e[i]=!1;const i=[];for(let t=2;t<=n;t++)e[t]&&(i.push(BigInt(t)),o.primalityMap.set(BigInt(t).toString(),!0));return i}if(t>2n**64n)throw new r("Basic sieve limit too large for direct processing, use segmentedSieveOfEratosthenes instead",{cause:{limit:t}});const n=BigInt(Number.MAX_SAFE_INTEGER),e=i.primalityTesting.basicSieveChunkSize?BigInt(i.primalityTesting.basicSieveChunkSize):100000n,s=i.primalityTesting.maxPrimesGenerated||1e6,a=[],c=h(t);let u;if(c<=1000000n)u=c<=n?m(c):[];else{u=[];for(let t=2n;t<=c;t++){let n=!0;for(let e=2n;e*e<=t;e++)if(t%e===0n){n=!1;break}if(n&&(u.push(t),o.primalityMap.set(t.toString(),!0)),u.length>=s/10)break}}t>=2n&&a.push(...u.filter((n=>n<=t)));let l=c+1n;if(l<2n&&(l=2n),l>t)return a;if(0===u.length){for(let n=l;n<=t;n++){let t=!0;if(n%2n===0n||n%3n===0n||n%5n===0n)t=!1;else for(let e=7n;e*e<=n;e+=2n)if(n%e===0n){t=!1;break}if(t&&(a.push(n),o.primalityMap.set(n.toString(),!0)),a.length>=s)break}return a}for(;l<=t;){const i=l+e-1n>t?t:l+e-1n,r=Math.min(Number(i-l+1n>n?n:i-l+1n),Number(e),1e6);if(r>0&&r<=1e6){const n=new Array(r).fill(!0);for(const t of u){let e=l;l%t!==0n&&(e=l+(t-l%t)),e===t&&(e+=t);for(let o=e;o<=i&&o-l<BigInt(r);o+=t){const t=Number(o-l);t>=0&&t<r&&(n[t]=!1)}}for(let e=0;e<r;e++)if(n[e]){const n=l+BigInt(e);n>=2n&&n<=t&&(a.push(n),o.primalityMap.set(n.toString(),!0),n>o.largestKnownPrime&&(o.largestKnownPrime=n))}}else for(let t=l;t<=i;t++){let n=!0;for(const e of u){if(e*e>t)break;if(t%e===0n){n=!1;break}}if(n&&t>=2n&&(a.push(t),o.primalityMap.set(t.toString(),!0)),a.length>=s)break}if(l=i+1n,a.length>=s)break}return a}function h(t){if(t<0n)throw new r("Cannot compute square root of negative number");if(t<2n)return t;let n=t,e=(n+1n)/2n;for(;e<n;)n=e,e=(n+t/n)/2n;return n}function g(t){if((t=f(t))<1n)return 2n;if(t<o.largestCheckedNumber){let n=t+1n;for(;n<=o.largestCheckedNumber;){if(!0===o.primalityMap.get(n.toString()))return n;n++}}let n=t+1n;for(n>2n&&n%2n===0n&&n++;!u(n);)n+=2n;return n}o.initialize();const p={getKnownPrimeCount(){let t=0;for(const n of o.primalityMap.values())n&&t++;return t},getLargestKnownPrime:()=>o.largestKnownPrime,getSmallPrimes:()=>[...o.knownPrimes],clear(t=1000n){t=f(t);const n=[];for(const e of o.primalityMap.keys()){BigInt(e)>t&&n.push(e)}for(const t of n)o.primalityMap.delete(t);if(o.largestKnownPrime>t){o.largestKnownPrime=o.knownPrimes[o.knownPrimes.length-1];for(const[n,e]of o.primalityMap.entries()){const i=BigInt(n);e&&i>o.largestKnownPrime&&i<=t&&(o.largestKnownPrime=i)}}o.largestCheckedNumber=t},getMaxCacheSize:()=>o.MAX_CACHE_SIZE,getStats(){let t=0,n=0;for(const e of o.primalityMap.values())e?t++:n++;return{size:o.primalityMap.size,maxSize:o.MAX_CACHE_SIZE,utilization:o.primalityMap.size/o.MAX_CACHE_SIZE,primes:t,composites:n,largestPrime:o.largestKnownPrime,largestChecked:o.largestCheckedNumber}},setMaxCacheSize(t,n={}){if("number"!=typeof t||!Number.isFinite(t)||t<=0)throw new r("Cache size must be a positive finite number",{cause:{provided:t,expected:"positive number"}});const i=!0===n.aggressive,{configure:s}=e(384);s({cache:{maxPrimeCacheSize:t}}),(i&&o.primalityMap.size>t||o.primalityMap.size>1.2*t)&&l()}};t.exports={PrimeMathError:r,fastExp:s,isDivisible:a,exactDivide:function(t,n){if(0n===n)throw new r("Division by zero is not allowed in the Prime Framework");if(!a(t,n))throw new r(`${t} is not divisible by ${n} in the natural numbers (Prime Framework requirement)`);return t/n},gcd:c,lcm:function(t,n){return 0n===t||0n===n?0n:(t=t<0n?-t:t)/c(t,n=n<0n?-n:n)*n},toBigInt:f,isPrime:u,nextPrime:g,factorial:function(t){if((t=f(t))<0n)throw new r("Factorial is not defined for negative numbers in the Prime Framework");if(0n===t)return 1n;let n=1n;for(let e=1n;e<=t;e++)n*=e;return n},primeCache:p,getPrimeRange:function(t,n,e={}){if(t=f(t),n=f(n),t<0n)throw new r("Start parameter must be non-negative");if(n<t)throw new r("End parameter must be greater than or equal to start parameter");const s=e.maxCount||i.primalityTesting.maxPrimesGenerated;if(t<2n&&(t=2n),n-t<1000000n){const e=[];for(let i=t;i<=n&&e.length<s;i++)u(i)&&e.push(i);return e}const a={segmentSize:e.segmentSize||null,maxCount:s};return void 0!==e.dynamic&&(a.dynamicSegmentSizing=e.dynamic),function(t,n,e={}){const r=[],s=e.maxCount||i.primalityTesting.maxPrimesGenerated||Number.MAX_SAFE_INTEGER;let a=e.segmentSize?f(e.segmentSize):null;if(!a){a=f(i.primalityTesting.segmentedSieveSize||1e6);if(void 0!==e.dynamicSegmentSizing?e.dynamicSegmentSizing:i.primalityTesting.dynamicSegmentSizing){const e=n-t+1n;e<10000000n?a=100000n:e>1000000000n&&(a=10000000n),"undefined"!=typeof window&&(a=a>1000000n?1000000n:a)}}const c=m(h(n)+1n);for(let e=t;e<=n&&!(r.length>=s);e+=a){const t=e+a-1n>n?n:e+a-1n,i=Number(t-e+1n),f=new Array(i).fill(!0);for(const n of c){let i=e;i%n!==0n&&(i=e+(n-e%n)),i===n&&(i+=n);for(let r=i;r<=t;r+=n)f[Number(r-e)]=!1}for(let t=0;t<i&&r.length<s;t++){const n=e+BigInt(t);f[t]&&n>=2n&&(r.push(n),o.primalityMap.set(n.toString(),!0),n>o.largestKnownPrime&&(o.largestKnownPrime=n))}}return r}(t,n,a)},primeGenerator:function*(t={}){const n=t.start?f(t.start):2n,e=t.end?f(t.end):null,i=t.count||Number.MAX_SAFE_INTEGER;let r=0,o=n<2n?2n:n;for(o>2n&&o%2n===0n?o++:2n===o&&(yield 2n,r++,o=3n);(null===e||o<=e)&&r<i;)u(o)&&(yield o,r++),o+=2n},getNthPrime:function(t){const n=f(t);if(n<=0n)throw new r("Index must be a positive integer");if(n<=BigInt(o.knownPrimes.length))return o.knownPrimes[Number(n-1n)];let e=BigInt(o.knownPrimes.length),i=o.knownPrimes[o.knownPrimes.length-1];for(;e<n;)i=g(i),e+=1n;return i},isMersennePrime:function(t){const n=f(t);if(!u(n))return!1;const e=n+1n;if(0n!==(e&e-1n))return!1;let i=0n,r=e;for(;r>1n;)r>>=1n,i++;return u(i)},moebiusFunction:function(t){const n=f(t);if(n<=0n)throw new r("Möbius function is only defined for positive integers");if(1n===n)return 1n;let e=n,i=1n,s=0n;for(let t=0;t<o.knownPrimes.length&&o.knownPrimes[t]*o.knownPrimes[t]<=e;t++){const n=o.knownPrimes[t];if(e%n===0n){if(e/=n,e%n===0n)return 0n;i=-i,s=n}}return e>1n&&e!==s&&(i=-i),i},quadraticResidue:function(t,n){const e=f(t),i=f(n);if(i<=1n)throw new r("Modulus must be positive");if(!u(i))throw new r("Modulus should be prime for reliable results");if(e%i===0n)return!0;if(i<100n){for(let t=1n;t<i;t++)if(t*t%i==e%i)return!0;return!1}let o=1n,s=e%i,a=(i-1n)/2n;for(;a>0n;)a%2n===1n&&(o=o*s%i),s=s*s%i,a/=2n;return 1n===o},__test__:null}},277:(t,n,e)=>{const{PrimeMathError:i,toBigInt:r,isPrime:o,gcd:s,primeCache:a,fastExp:c}=e(253),{config:f}=e(384);const u={get MAX_CACHE_SIZE(){return f.cache.maxFactorizationCacheSize},get PERSISTENT_CACHE_ENABLED(){return f.cache.persistentCache},get STORAGE_KEY(){return"math-js-factorization-cache"},cache:new Map,stats:{hits:0,misses:0,total:0,lastPruneTime:Date.now()},metrics:new Map,initialize(){this.PERSISTENT_CACHE_ENABLED&&this.loadFromStorage()},setMaxSize(t){if("number"!=typeof t||t<=0||!Number.isFinite(t))throw new i("Cache size must be a positive finite number",{cause:{provided:t,expected:"positive number"}});const{configure:n}=e(384);n({cache:{maxFactorizationCacheSize:t}}),this.cache.size>this.MAX_CACHE_SIZE&&this.prune()},get(t){this.stats.total++;const n=t.toString(),e=this.cache.get(n);if(e){const t=this.metrics.get(n)||{accessCount:0,computationCost:1,lastAccess:0};return t.accessCount++,t.lastAccess=Date.now(),this.metrics.set(n,t),this.stats.hits++,{factors:new Map(e.factors),isComplete:e.isComplete,confidence:e.confidence}}return this.stats.misses++,null},set(t,n,e=!0,r=1,o={}){const s=t.toString(),a=o.computationCost||1;for(const[t]of n.entries())if(t<=0n)throw new i("Invalid prime factor in factorization",{cause:{prime:t,expected:"positive prime"}});this.cache.set(s,{factors:new Map(n),isComplete:e,confidence:r});const c=this.metrics.get(s);this.metrics.set(s,{lastAccess:Date.now(),accessCount:c?c.accessCount+1:1,computationCost:a}),this.cache.size>this.MAX_CACHE_SIZE&&this.prune(),this.PERSISTENT_CACHE_ENABLED&&setTimeout((()=>{this.saveToStorage()}),0)},prune(){const t=Date.now();if(this.stats.lastPruneTime=t,this.cache.size<1.1*this.MAX_CACHE_SIZE)return;const n=[],e=t-this.stats.lastPruneTime+1e3;for(const[i,r]of this.cache.entries()){const o=this.metrics.get(i)||{lastAccess:0,accessCount:0,computationCost:1},s=.35*Math.max(0,1-(t-o.lastAccess)/e)+.25*Math.min(1,o.accessCount/10)+.3*Math.min(1,o.computationCost/10)+.1*(r.isComplete?r.confidence:.5*r.confidence);n.push({key:i,weight:s})}n.sort(((t,n)=>t.weight-n.weight));const i=Math.floor(.8*this.MAX_CACHE_SIZE),r=this.cache.size-i;for(let t=0;t<r;t++)if(t<n.length){const e=n[t].key;this.cache.delete(e),this.metrics.delete(e)}},clear(){if(this.cache.clear(),this.metrics.clear(),this.stats.hits=0,this.stats.misses=0,this.stats.total=0,this.stats.lastPruneTime=Date.now(),this.PERSISTENT_CACHE_ENABLED)try{if("undefined"!=typeof localStorage)localStorage.removeItem(this.STORAGE_KEY);else if(void 0!==e.g&&"undefined"!=typeof process){const t=e(603),n=e(975),i=process.env.HOME||process.env.USERPROFILE;if(i){const e=n.join(i,".math-js-cache"),r=n.join(e,`${this.STORAGE_KEY}.json`);t.existsSync(r)&&t.unlinkSync(r)}}}catch(t){}},size(){return this.cache.size},getStats(){const t=this.stats.total>0?this.stats.hits/this.stats.total:0;return{size:this.cache.size,maxSize:this.MAX_CACHE_SIZE,hits:this.stats.hits,misses:this.stats.misses,hitRate:t,efficiency:t*(this.cache.size/this.MAX_CACHE_SIZE),persistenceEnabled:this.PERSISTENT_CACHE_ENABLED}},saveToStorage(){if(!this.PERSISTENT_CACHE_ENABLED)return!1;try{const t={version:1,timestamp:Date.now(),entries:[],metrics:[]},n=[],i=Date.now();for(const[t,e]of this.cache.entries()){const r=this.metrics.get(t)||{lastAccess:0,accessCount:0,computationCost:1},o=Math.max(0,1-(i-r.lastAccess)/864e5),s=Math.min(1,r.accessCount/10),a=Math.min(1,r.computationCost/10),c=.35*o+.25*s+.3*a+.1*(e.isComplete?e.confidence:.5*e.confidence);n.push({key:t,entry:e,metrics:r,weight:c})}n.sort(((t,n)=>n.weight-t.weight));const r=Math.min(this.MAX_CACHE_SIZE,n.length);for(let e=0;e<r;e++){const{key:i,entry:r,metrics:o}=n[e],s=[];for(const[t,n]of r.factors)s.push([t.toString(),n.toString()]);t.entries.push({key:i,factorArray:s,isComplete:r.isComplete,confidence:r.confidence}),t.metrics.push({key:i,lastAccess:o.lastAccess,accessCount:o.accessCount,computationCost:o.computationCost})}const o=JSON.stringify(t);if("undefined"!=typeof localStorage)localStorage.setItem(this.STORAGE_KEY,o);else if(void 0!==e.g&&"undefined"!=typeof process)try{const t=e(603),n=e(975),i=process.env.HOME||process.env.USERPROFILE;if(i){const e=n.join(i,".math-js-cache");t.existsSync(e)||t.mkdirSync(e,{recursive:!0});const r=n.join(e,`${this.STORAGE_KEY}.json`);t.writeFileSync(r,o,"utf8")}}catch(t){return!1}return!0}catch(t){return!1}},loadFromStorage(){if(!this.PERSISTENT_CACHE_ENABLED)return!1;try{let t=null;if("undefined"!=typeof localStorage)t=localStorage.getItem(this.STORAGE_KEY);else if(void 0!==e.g&&"undefined"!=typeof process)try{const n=e(603),i=e(975),r=process.env.HOME||process.env.USERPROFILE;if(r){const e=i.join(r,".math-js-cache"),o=i.join(e,`${this.STORAGE_KEY}.json`);n.existsSync(o)&&(t=n.readFileSync(o,"utf8"))}}catch(t){return!1}if(!t)return!1;const n=JSON.parse(t);if(1!==n.version)return!1;if(Date.now()-n.timestamp>2592e6)return!1;this.clear();for(const t of n.entries){const n=new Map;for(const[e,i]of t.factorArray)n.set(BigInt(e),BigInt(i));this.cache.set(t.key,{factors:n,isComplete:t.isComplete,confidence:t.confidence})}for(const t of n.metrics)this.metrics.set(t.key,{lastAccess:t.lastAccess,accessCount:t.accessCount,computationCost:t.computationCost});return this.stats.hits=0,this.stats.misses=0,this.stats.total=0,this.stats.lastPruneTime=Date.now(),!0}catch(t){return!1}},setPersistence(t){const{configure:n}=e(384);n({cache:{persistentCache:!!t}}),t&&this.saveToStorage()}};function l(t){let n=r(t);if(n<=0n)throw new i("Factorization is only defined for positive integers");if(1n===n)return new Map;const e=new Map;let o=0n;for(;n%2n===0n;)o++,n/=2n;o>0n&&e.set(2n,o);let s=3n;for(;s*s<=n;){for(o=0n;n%s===0n;)o++,n/=s;o>0n&&e.set(s,o),s+=2n}return n>1n&&e.set(n,1n),e}function m(t){let n=r(t);if(n<=0n)throw new i("Factorization is only defined for positive integers");if(1n===n)return new Map;const e=new Map,o=[2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n,41n,43n,47n,53n,59n,61n,67n,71n,73n,79n,83n,89n,97n];for(const t of o){if(1n===n)break;let i=0n;for(;n%t===0n;)i++,n/=t;if(i>0n&&e.set(t,i),t*t>n)return n>1n&&e.set(n,1n),e}let s=101n;for(;s*s<=n;){let t=0n;for(;n%s===0n;)t++,n/=s;t>0n&&e.set(s,t),s+=2n}return n>1n&&e.set(n,1n),e}function h(t,n=25){if(t<=1n)return!1;if(t<=3n)return!0;if(t%2n===0n)return!1;let e=0n,i=t-1n;for(;i%2n===0n;)i/=2n,e++;const r=n=>{let r=function(t,n,e){if(1n===e)return 0n;let i=1n;t%=e;for(;n>0n;)n%2n===1n&&(i=i*t%e),n>>=1n,t=t*t%e;return i}(n,i,t);if(1n===r||r===t-1n)return!0;for(let n=1n;n<e;n++)if(r=r*r%t,r===t-1n)return!0;return!1};for(let e=0;e<n;e++){const n=[2n,3n,5n,7n,11n,13n,17n,19n,23n,29n,31n,37n];if(!r(n[e%n.length]%(t-2n)+2n))return!1}return!0}function g(t,n={}){if(t<=1n)return t;if(t%2n===0n)return 2n;if(t%3n===0n)return 3n;if(o(t))return t;const e=n.maxIterations,i=n.timeLimit||f.factorization.timeLimit,a=void 0!==n.c?r(n.c):1n,c=n=>(n*n+a)%t,u=[2n,3n,5n,7n,11n,13n,17n,19n],l=i?Date.now():0;for(const n of u){let r=n,o=n,a=1n,f=1n,u=1n,m=0;for(;1n===a&&(void 0===e||m<e)&&(void 0===i||Date.now()-l<i);){if(u===f&&(o=r,f*=2n,u=0n),r=c(r),u+=1n,a=s(r>o?r-o:o-r,t),a>1n&&a<t)return a;m++}if(a!==t)return a}return t}function p(t,n={}){if((t=r(t))<=1n)throw new i("Input must be greater than 1",{cause:{value:t,function:"quadraticSieve"}});if(t%2n===0n)return 2n;if(t%3n===0n)return 3n;if(t%5n===0n)return 5n;if(h(t,40))return t;if(t<BigInt(10)**BigInt(f.factorization.thresholds.trialDivision)){for(let n=7n;n*n<=t;n+=2n)if(t%n===0n)return n;return t}const e=n.factorBaseSize||(t<10n**40n?100:t<10n**60n?300:t<10n**80n?500:1e3),u=n.sieveSize||(t<10n**40n?1e4:t<10n**60n?5e4:t<10n**80n?1e5:2e5),l=n.numRelations||e+20,m=function(t,n){const e=[];e.push(2n);const i=a.getSmallPrimes();let r=1;for(;e.length<n&&r<i.length;){const n=i[r++];2n!==n&&1!==d(t%n,n)||e.push(n)}if(e.length<n){let r=i[i.length-1]+2n;for(;e.length<n;)o(r)&&1===d(t%r,r)&&e.push(r),r+=2n}return e}(t,e),{relations:g,matrixSize:y}=function(t,n,e,i){const r=v(t);let o=r;const s=[],a=n[n.length-1],c=new Map;for(const e of n)2n===e?c.set(e,[1n]):c.set(e,b(t,e));let f=0;const u=100;for(;s.length<i&&f<u;){f++;const r=new Array(e).fill(0);for(let t=0;t<n.length;t++){const e=n[t],i=c.get(e);if(i&&i.length>0)for(const t of i){for(let n=Number((t-o%e+e)%e);n<r.length;n+=Number(e))r[n]+=Math.log2(Number(e))}}const u=.9*Math.log2(Number(a));for(let e=0;e<r.length;e++)if(r[e]>=u){const r=o+BigInt(e),a=r*r%t,c=w(a,n);if(c.size>0&&(s.push({x:r,qx:a,factorization:c}),s.length>=i))break}o+=BigInt(e)}return{relations:s,matrixSize:n.length}}(t,m,u,l);if(g.length<e)return!0!==n.retry?p(t,{...n,factorBaseSize:1.5*e,sieveSize:1.5*u,retry:!0}):t;const z=function(t,n,e){const i=new Map;for(let t=0;t<n.length;t++)i.set(n[t],t);const r=[];for(let n=0;n<t.length;n++)r.push(new Array(e).fill(0));for(let n=0;n<t.length;n++){const e=t[n];for(const[t,o]of e.factorization){const e=i.get(t);void 0!==e&&(r[n][e]=Number(o%2n))}}return r}(g,m,y),S=function(t,n,e){const i=[];for(let n=0;n<e;n++){const r=[...t[n]];for(let t=0;t<e;t++)r.push(n===t?1:0);i.push(r)}for(let t=0;t<n&&t<e;t++){let n=-1;for(let r=t;r<e;r++)if(1===i[r][t]){n=r;break}if(-1!==n){n!==t&&([i[t],i[n]]=[i[n],i[t]]);for(let n=0;n<e;n++)if(n!==t&&1===i[n][t])for(let e=t;e<i[n].length;e++)i[n][e]=(i[n][e]+i[t][e])%2}}const r=[];for(let t=0;t<e;t++){let e=!0;for(let r=0;r<n;r++)if(1===i[t][r]){e=!1;break}if(e){const e=i[t].slice(n);r.push(e)}}return r}(z,y,g.length);for(const n of S){if(n.reduce(((t,n)=>t+n),0)<=1)continue;let e=1n;const i=new Map;for(let r=0;r<n.length;r++)if(1===n[r]){const n=g[r];e=e*n.x%t;for(const[t,e]of n.factorization){const n=i.get(t)||0n;i.set(t,(n+e)%2n)}}let r=1n;for(const[n,e]of i)e%2n===0n&&(r=r*c(n,e/2n)%t);const o=s((e+r)%t,t);if(1n!==o&&o!==t)return o;const a=s((e-r+t)%t,t);if(1n!==a&&a!==t)return a}return!0!==n.retry?p(t,{...n,factorBaseSize:2*e,sieveSize:2*u,retry:!0}):t}function w(t,n){const e=new Map;let i=t;for(const t of n){let n=0n;for(;i%t===0n;)n++,i/=t;if(n>0n&&e.set(t,n),1n===i)break}return 1n!==i?new Map:e}function d(t,n){if(n<=0n||n%2n===0n)throw new i("Jacobi symbol denominator must be a positive odd number");t=(t%n+n)%n;let e=1;for(;0n!==t;){let i=0n;for(;t%2n===0n;)t/=2n,i++;if(i%2n===1n){const t=Number(n%8n);3!==t&&5!==t||(e=-e)}t%4n===3n&&n%4n===3n&&(e=-e);const r=t;t=n%t,n=r}return 1n===n?e:0}function b(t,n){if(2n===n)return[1n];if(1!==d(t=(t%n+n)%n,n))return[];if(n%4n===3n){const e=c(t,(n+1n)/4n)%n;return[e,n-e]}let e=n-1n,i=0n;for(;e%2n===0n;)e/=2n,i++;let r=2n;for(;-1!==d(r,n);)r++;let o=i,s=c(r,e)%n,a=c(t,e)%n,f=c(t,(e+1n)/2n)%n;for(;1n!==a;){if(0n===a)return[0n];if(1n===a)return[f,n-f];let t=0n,e=a;for(;1n!==e;)if(e=e*e%n,t++,t>=o)return[];let i=s;for(let e=0n;e<o-t-1n;e++)i=i*i%n;if(o=t,s=i*i%n,a=a*s%n,f=f*i%n,1n===a)return[f,n-f]}}function v(t){if(t<0n)throw new i("Cannot compute square root of negative number");if(t<2n)return t;let n=t,e=(n+1n)/2n;for(;e<n;)n=e,e=(n+t/n)/2n;return n}function y(t,n={}){if((t=r(t))<=1n)throw new i("Input must be greater than 1",{cause:{value:t,function:"ellipticCurveMethod"}});if(t%2n===0n)return 2n;if(t%3n===0n)return 3n;if(t%5n===0n)return 5n;if(t%7n===0n)return 7n;if(h(t,25))return t;if(t<BigInt(10)**BigInt(f.factorization.thresholds.trialDivision)){const n=a.getSmallPrimes();for(const e of n){if(e*e>t)break;if(t%e===0n)return e}for(let n=1009n;n*n<=t;n+=2n)if(t%n===0n)return n;return t}const e=t.toString().length,o=f.factorization.ecm,c=20+Math.floor(e/5),u=o.maxCurves,l=n.curves||Math.min(c,u),m=n.b1||o.defaultB1,g=o.b1ScaleFactor,p=Math.round(m*Math.pow(g,Math.min(e-15,15))),w=n.b2||o.defaultB2||100*p,d=n.maxMemory||f.factorization.memoryLimit||o.maxMemory||o.defaultMemory,b=d?1024*d*1024/16:Number.MAX_SAFE_INTEGER,v=Math.min(p,1e5),y=[],N=a.getSmallPrimes();for(const t of N)Number(t)<=v&&y.push(Number(t));if(v>Number(N[N.length-1])){const t=BigInt(v);let n=N[N.length-1]+2n;for(;n<=t;){let t=!0;for(const e of N){if(e*e>n)break;if(n%e===0n){t=!1;break}}t&&y.push(Number(n)),n+=2n}}for(let n=0;n<l;n++){const e=BigInt(n+1),i=(e*e+3n)*e%t;if(0n===i||1n===i)continue;const r=(i*i-5n)%t,o=4n*i%t;let a=(o-r)*_(4n*r*o%t,t)%t;a<0n&&(a+=t);let c={x:r,z:o};try{for(const n of y){let e=n;for(;e<=p/n;)e*=n;c=S(c,BigInt(e),a,t);const i=s(c.z,t);if(1n!==i&&i!==t)return i}if(w>p&&0n!==c.z){const n=z(c,a,t,p,w,b);if(1n!==n&&n!==t)return n}}catch(n){if(n instanceof Error&&n.cause&&n.cause.gcd){const e=n.cause.gcd;if(1n!==e&&e!==t)return e}}}return t}function z(t,n,e,i,r,a){const c=s(2n*t.z,e);if(1n!==c)return c;let f=1n;const u=Math.floor(Math.sqrt(r-i)),l=Math.min(Math.ceil((r-i)/u),a),m=[];let h=t;m.push(h);for(let t=2;t<u;t++)h=M(m[0],m[t-2],h,n,e),m.push(h);const g=S(t,BigInt(u),n,e);let p=Math.floor(i/u)*u,w=S(t,BigInt(p),n,e);for(let a=0;a<l&&p<r;a++){p+=u;w=M(g,w,t,n,e);for(let c=0;c<m.length;c++){const u=p-c;if(u>i&&u<=r&&o(BigInt(u))){if(f=f*M(w,m[c-1],t,n,e,!0).z%e,a%100==99){const t=s(f,e);if(1n!==t&&t!==e)return t;f=1n}}}}if(1n!==f){const t=s(f,e);if(1n!==t&&t!==e)return t}return 1n}function S(t,n,e,i){let r={x:1n,z:0n},o={...t};const s=n.toString(2).split("").map(Number);for(let n=0;n<s.length;n++){0===s[n]?(o=M(r,o,t,e,i),r=N(r,e,i)):(r=M(r,o,t,e,i),o=N(o,e,i))}return r}function N(t,n,e){if(0n===t.z)return t;const i=(t.x+t.z)*(t.x+t.z)%e,r=(t.x-t.z)*(t.x-t.z)%e;let o=(i-r)%e;o<0n&&(o+=e);return{x:i*r%e,z:o*(((n+2n)*i/4n+r)%e)%e}}function M(t,n,e,i,r,o=!1){if(0n===t.z)return n;if(0n===n.z)return t;const s=(t.x+t.z)*(n.x-n.z)%r,a=(t.x-t.z)*(n.x+n.z)%r;let c=(s+a)%r;c<0n&&(c+=r);let f=(s-a)%r;f<0n&&(f+=r);const u=e.x*c*c%r,l=e.z*f*f%r;return o?{z:f}:{x:u,z:l}}function _(t,n){let e=0n,i=1n,r=n,o=t=(t%n+n)%n;for(;0n!==o;){const t=r/o,n=i;i=e-t*i,e=n;const s=o;o=r-t*o,r=s}if(r>1n){throw new Error("Modular inverse does not exist - GCD found",{cause:{gcd:r}})}return e<0n&&(e+=n),e}function I(t,n=new Map,e={}){if(1n===t)return n;const i=u.get(t);if(i){for(const[t,e]of i.factors.entries()){const i=n.get(t)||0n;n.set(t,i+e)}return n}if(o(t)){const e=n.get(t)||0n;return n.set(t,e+1n),u.set(t,new Map([[t,1n]]),!0,1,{computationCost:1}),n}let r;const s=t.toString().length;if(t<10000n?r=function(t){for(const n of a.getSmallPrimes()){if(t%n===0n)return n;if(n*n>t)break}const n=v(t);for(let e=101n;e<=n;e+=2n)if(t%e===0n)return e;return t}(t):t<10n**12n?r=g(t,e):t<10n**25n?(r=g(t,{...e,timeLimit:e.timeLimit||1e4,c:(e.iteration||0)%5==0?1n:(e.iteration||0)%5==1?2n:(e.iteration||0)%5==2?3n:(e.iteration||0)%5==3?-1n:7n}),r===t&&(r=y(t,{curves:5,b1:1e4}))):t<10n**40n?(r=y(t,{curves:e.ecmCurves||Math.min(15,5+Math.floor(s/5)),b1:e.ecmB1||5e4*Math.floor(s/10),b2:e.ecmB2||0}),r===t&&e.advanced&&(r=p(t,{factorBaseSize:e.qsFactorBase||100,sieveSize:e.qsSieveSize||1e4}))):(r=p(t,{factorBaseSize:e.qsFactorBase||Math.min(500,100+20*Math.floor(s/5)),sieveSize:e.qsSieveSize||Math.min(1e5,1e4+1e3*s),verbose:e.verbose}),r===t&&e.advanced&&(r=y(t,{curves:e.ecmCurves||30,b1:e.ecmB1||1e6,b2:e.ecmB2||1e8}))),r===t){if(e.partialFactorization){const i=n.get(t)||0n;n.set(t,i+1n);const r=e.advanced?.95:.8;return u.set(t,new Map([[t,1n]]),!1,r,{computationCost:10}),n}if(e.iteration&&e.iteration<3)return I(t,n,{...e,iteration:(e.iteration||0)+1,c:(e.c||1n)+1n});{const e=n.get(t)||0n;n.set(t,e+1n);const i=o(t,{useCache:!1})?1:.9;return u.set(t,new Map([[t,1n]]),!0,i),n}}const c={...e,iteration:0};return I(r,n,c),I(t/r,n,c),n}function E(t,n={}){let e=r(t);if(e<=0n)throw new i("Factorization is only defined for positive integers");if(1n===e)return new Map;const o=!1!==n.useCache;if(o){const t=u.get(e);if(t)return new Map(t.factors)}const s=new Map,a=[2n,3n,5n,7n,11n,13n];for(const t of a){let n=0n;for(;e%t===0n;)n++,e/=t;if(n>0n&&s.set(t,n),1n===e)break}if(e>1n){I(e,s,{...n,advanced:!1!==n.advanced,ecmCurves:n.ecmCurves||15,ecmB1:n.ecmB1||1e5,qsFactorBase:n.qsFactorBase||100,qsSieveSize:n.qsSieveSize||1e4})}return o&&u.set(t,s),s}function C(t,n={}){let e;try{e=r(t)}catch(n){throw new i(`Failed to convert input to BigInt: ${function(t){if(t instanceof Error)try{return t.message}catch(t){return"Error: Could not extract message"}else try{return String(t)}catch(t){return"Unknown error"}}(n)}`,{cause:{input:String(t).substring(0,100)+(String(t).length>100?"...":"")}})}const{advanced:s=!1,useCache:a=!0,parallelizeFactorization:c=!1,partialFactorization:h=!1,validateFactors:g=!0,algorithmParams:p={}}=n,w=f.factorization.thresholds;if(e<=0n)throw new i("Factorization is only defined for positive integers in the Prime Framework");if(1n===e)return new Map;if(a)try{const t=u.get(e);if(t)return new Map(t.factors)}catch(t){}try{if(o(e)){const t=new Map([[e,1n]]);if(a)try{u.set(e,t,!0,1,{computationCost:1})}catch(t){}return t}}catch(t){}const d=e.toString().length;let b;if(d<=w.trialDivision)b=l(e);else if(d<=w.optimizedTrialDivision)b=m(e);else if(d<=w.pollardRho)if(s){const t=new Map,n=B(e);let i=e;if(n.size>0){for(const[e,r]of n.entries())t.set(e,r),i/=e**r;1n===i?b=t:o(i)&&(t.set(i,1n),b=t)}b||(b=E(i,{useCache:a,advanced:!0,partialFactorization:!1,initialFactors:t,...p}))}else b=E(e,{useCache:a,advanced:!1,...p});else if(d<=w.ecm)if(s){const t={useCache:a,advanced:!0,partialFactorization:!1,ecmCurves:p.ecmCurves||Math.min(20,5+Math.floor(d/4)),ecmB1:p.ecmB1||Math.min(5e5,1e4*Math.floor(d/5)),ecmB2:p.ecmB2||0,...p};b=c?A(e,t):E(e,t)}else b=E(e,{useCache:a,advanced:!1,ecmCurves:p.ecmCurves||10,ecmB1:p.ecmB1||5e4,...p});else if(d<=w.quadraticSieve){if(!s&&!h)throw new i("Number is too large ("+d+" digits) for non-advanced factorization. Use advanced=true or partialFactorization=true to proceed.");const t={useCache:a,advanced:!0,parallelizeFactorization:c,partialFactorization:h,ecmCurves:p.ecmCurves||Math.min(30,10+Math.floor(d/5)),ecmB1:p.ecmB1||1e5*Math.floor(d/20),ecmB2:p.ecmB2||Math.min(1e8,1e6*Math.floor(d/20)),qsFactorBase:p.qsFactorBase||Math.min(500,100+20*Math.floor(d/4)),qsSieveSize:p.qsSieveSize||Math.min(1e5,1e4+500*d),...p},n=new Map;let r=e;const f=B(r);if(f.size>0){for(const[t,e]of f.entries())n.set(t,e),r/=t**e;1n===r?b=n:o(r)&&(n.set(r,1n),b=n)}if(!b)if(c){const e=A(r,t);for(const[t,i]of e.entries()){const e=n.get(t)||0n;n.set(t,e+i)}b=n}else{const e=y(r,t);if(e!==r&&e>1n){const i=E(e,t),o=r/e;for(const[t,e]of i.entries()){const i=n.get(t)||0n;n.set(t,i+e)}const s=E(o,t);for(const[t,e]of s.entries()){const i=n.get(t)||0n;n.set(t,i+e)}b=n}else{const e=E(r,t);for(const[t,i]of e.entries()){const e=n.get(t)||0n;n.set(t,e+i)}b=n}}}else{if(!h)throw new i("Number is too large ("+d+" digits) for complete factorization under Prime Framework constraints. Use partialFactorization=true to allow partial results.");const t={useCache:a,advanced:!0,parallelizeFactorization:c,partialFactorization:!0,ecmCurves:p.ecmCurves||50,ecmB1:p.ecmB1||2e6,qsFactorBase:p.qsFactorBase||1e3,...p};b=c?A(e,t):E(e,t)}if(g){for(const t of b.keys())if(!o(t))throw new i(`Non-prime factor ${t} found in factorization result. This is a bug.`);const t=x(b,e);if(!t&&!h)throw new i("Incomplete factorization result. This is a bug in the factorization algorithm.");a&&u.set(e,b,t,t?1:.9,{computationCost:Math.min(10,1+Math.floor(d/10))})}return b}function B(t,n=1e3){const e=new Map;let i=t;const r=a.getSmallPrimes();for(const t of r){if(t>n)break;let r=0n;for(;i%t===0n;)r++,i/=t;if(r>0n&&e.set(t,r),1n===i)break;if(t*t>i){i>1n&&e.set(i,1n);break}}return e}function x(t,n){let e=1n;for(const[n,i]of t.entries()){let t=n,r=i,o=1n;for(;r>0n;)r%2n===1n&&(o*=t),t*=t,r/=2n;e*=o}return e===n}function F(t){return[...C(t).keys()]}function A(t,n={}){const e=r(t);if(e<=0n)throw new i("Factorization is only defined for positive integers");if(1n===e)return new Map;const s=!1!==n.useCache;if(s){const t=u.get(e);if(t)return new Map(t.factors)}if(e<10n**20n)return C(e,n);const c=new Map;let f=e;const l=a.getSmallPrimes();for(const t of l){if(t*t>f)break;let n=0n;for(;f%t===0n;)n++,f/=t;n>0n&&c.set(t,n)}if(1n===f)return c;if(o(f))return c.set(f,1n),c;const m=g(f,{timeLimit:n.timeLimit,c:1n});if(m===f){const t=y(f,{curves:10,b1:1e5});if(t===f){const t=p(f,{factorBase:100,sieveSize:1e4});if(t===f)return c.set(f,1n),c;{const e=C(t,n),i=C(f/t,n);for(const[t,n]of e.entries())c.set(t,n);for(const[t,n]of i.entries()){const e=c.get(t)||0n;c.set(t,e+n)}}}else{const e=C(t,n),i=C(f/t,n);for(const[t,n]of e.entries())c.set(t,n);for(const[t,n]of i.entries()){const e=c.get(t)||0n;c.set(t,e+n)}}}else{const t=C(m,n),e=C(f/m,n);for(const[n,e]of t.entries())c.set(n,e);for(const[t,n]of e.entries()){const e=c.get(t)||0n;c.set(t,e+n)}}return s&&u.set(e,c),c}const P={size:()=>u.size(),clear(){u.clear()},setMaxSize(t){u.setMaxSize(t)},getStats:()=>u.getStats(),setPersistence(t){u.setPersistence(t)},saveToStorage:()=>u.saveToStorage(),loadFromStorage:()=>u.loadFromStorage()};u.initialize(),t.exports={factorize:l,factorizeWithPrimes:m,factorizePollardsRho:E,factorizeOptimal:C,factorizeParallel:A,quadraticSieve:p,ellipticCurveMethod:y,millerRabinTest:h,pollardRho:g,isFactorizationComplete:x,fromPrimeFactors:function(t,n={}){if(!t||t instanceof Map&&0===t.size||Array.isArray(t)&&0===t.length)return 1n;const e=!1!==n.validatePrimality,s=!1!==n.enforceCanonicalForm,a=t instanceof Map?t:new Map(t.map((t=>[r(t.prime),r(t.exponent)]))),c=new Map;for(const[t,n]of a.entries()){if(n<=0n)throw new i("Exponents must be positive integers",{cause:{prime:t,exponent:n,expected:"positive exponent"}});if(e&&!o(t))throw new i(`Factor ${t} is not a prime number`,{cause:{prime:t,function:"fromPrimeFactors"}});const r=c.get(t)||0n;c.set(t,r+n)}let f=[...c.entries()];s&&f.sort(((t,n)=>t[0]<n[0]?-1:t[0]>n[0]?1:0));let u=1n;if(f.length>5){const t=[];for(let n=0;n<f.length;n+=5){const e=f.slice(n,Math.min(n+5,f.length));let i=1n;for(const[t,n]of e){let e=t,r=n,o=1n;for(;r>0n;)r%2n===1n&&(o*=e),e*=e,r/=2n;i*=o}t.push(i)}for(const n of t)u*=n}else for(const[t,n]of f){let e=t,i=n,r=1n;for(;i>0n;)i%2n===1n&&(r*=e),e*=e,i/=2n;u*=r}return u},getPrimeFactors:F,factorMapToArray:function(t){return[...t.entries()].map((([t,n])=>({prime:t,exponent:n})))},factorArrayToMap:function(t){return new Map(t.map((t=>[r(t.prime),r(t.exponent)])))},getRadical:function(t){return F(t).reduce(((t,n)=>t*n),1n)},getPrimeSignature:function(t){const n=C(t);let e=1n;for(const[t,i]of n.entries()){let n=1n,r=t,o=i;for(;o>0n;)o%2n===1n&&(n*=r),r*=r,o/=2n;e*=(t-1n)*(n-1n)}return e},factorizationCache:P}},384:(t,n,e)=>{const i={performanceProfile:"balanced",cache:{enabled:!0,maxSize:10485760,evictionPolicy:"lru",maxPrimeCacheSize:1e5,maxFactorizationCacheSize:1e3,persistentCache:!1,ttl:0},factorization:{lazy:!0,completeSizeLimit:100,algorithm:"auto",timeLimit:0,memoryLimit:0,maxIterations:1e6,thresholds:{trialDivision:6,optimizedTrialDivision:12,pollardRho:25,ecm:50,quadraticSieve:100},ecm:{maxCurves:100,defaultB1:1e5,defaultB2:0,maxMemory:0,b1ScaleFactor:1.1,defaultMemory:100}},async:{useWorkers:!0,defaultTimeout:3e4,reportProgress:!0,maxWorkers:4},memory:{optimizeMemory:!1,useCompactRepresentation:!1,maxMemoryUsage:0,gcStrategy:"auto"},primalityTesting:{millerRabinRounds:40,deterministicTestLimit:20,useTrialDivision:!0,segmentedSieveSize:1e6,dynamicSegmentSizing:!0,basicSieveChunkSize:1e6,maxPrimesGenerated:1e7,verificationThreshold:1e6},conversion:{directConversionLimit:1e3,defaultBase:10,cacheResults:!0,minBase:2,maxBase:36},errorHandling:{includeStackTrace:!0,verbosity:"standard",strictMode:!1}};let r=JSON.parse(JSON.stringify(i));function o(t){const n=t.split(".");let e=i,o=r;for(const t of n)if(e=e[t],o=o[t],void 0===e||void 0===o)return!1;return JSON.stringify(e)!==JSON.stringify(o)}(function(){if("undefined"!=typeof window){return/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test("undefined"!=typeof navigator?navigator.userAgent:"")}try{const t=e(72);return t.totalmem()<1073741824}catch(t){return!1}})()&&(r.cache.maxSize=2097152,r.cache.maxPrimeCacheSize=5e3,r.cache.maxFactorizationCacheSize=100,r.factorization.completeSizeLimit=50,r.memory.optimizeMemory=!0),t.exports={configure:function(t){if(!t||"object"!=typeof t)throw new Error("Configuration options must be an object");return function t(n,e){for(const i in e)Object.prototype.hasOwnProperty.call(e,i)&&(e[i]instanceof Object&&i in n&&n[i]instanceof Object?t(n[i],e[i]):n[i]=e[i]);return n}(r,t),function(){switch(r.performanceProfile){case"speed":o("cache.enabled")||(r.cache.enabled=!0),o("factorization.lazy")||(r.factorization.lazy=!0),o("memory.optimizeMemory")||(r.memory.optimizeMemory=!1);break;case"precision":o("factorization.lazy")||(r.factorization.lazy=!1),o("primalityTesting.millerRabinRounds")||(r.primalityTesting.millerRabinRounds=100),o("errorHandling.strictMode")||(r.errorHandling.strictMode=!0)}r.memory.optimizeMemory&&(o("cache.maxSize")||(r.cache.maxSize=2097152),o("cache.maxPrimeCacheSize")||(r.cache.maxPrimeCacheSize=1e4),o("cache.maxFactorizationCacheSize")||(r.cache.maxFactorizationCacheSize=200))}(),r},resetConfig:function(){return r=JSON.parse(JSON.stringify(i)),r},getConfig:function(){return JSON.parse(JSON.stringify(r))},config:r}},488:(t,n,e)=>{const{PrimeMathError:i,toBigInt:r,isPrime:o}=e(253),{factorizeOptimal:s,factorArrayToMap:a,millerRabinTest:c,fromPrimeFactors:f}=e(277),u=e(82),{config:l}=e(384);class m{constructor(t){if(this._factorization=new Map,this._isNegative=!1,this._isZero=!1,null==t)throw new i("Value cannot be null or undefined");if("number"==typeof t&&0===t||"string"==typeof t&&/^[+-]?0+$/.test(t)||"bigint"==typeof t&&0n===t)return this._isZero=!0,this._factorization=new Map,void(this._isNegative=!1);if("number"==typeof t&&1===t||"string"==typeof t&&/^[+]?1$/.test(t)||"bigint"==typeof t&&1n===t)return this._factorization=new Map,void(this._isNegative=!1);if(t instanceof m)return this._factorization=new Map(t._factorization),this._isNegative=t._isNegative,void(this._isZero=t._isZero);if(t instanceof Map)return this._validateFactorization(t),this._factorization=new Map(t),this._normalizeFactorization(),void(this._isNegative=!1);if(t&&"object"==typeof t&&"factorization"in t){if(!(t.factorization instanceof Map))throw new i("Factorization must be a Map of prime factors");return!0===t.isZero?(this._isZero=!0,this._factorization=new Map,void(this._isNegative=!1)):(this._validateFactorization(t.factorization),this._factorization=new Map(t.factorization),this._normalizeFactorization(),this._isNegative=!!t.isNegative,void(this._isZero=!1))}try{if("number"==typeof t){if(!Number.isFinite(t))throw new i("Cannot convert infinite or NaN value to UniversalNumber");if(!Number.isInteger(t))throw new i("UniversalNumber requires an integer value");const n=u.fromNumber(t);this._factorization=n.factorization,this._isNegative=n.isNegative}else if("string"==typeof t){const n=arguments.length>1&&"number"==typeof arguments[1]?arguments[1]:10;try{if(t.length>500){const e=t.startsWith("-"),r=e?t.slice(1):t;for(let t=0;t<r.length;t++){const e=r[t],o=parseInt(e,n);if(isNaN(o)||o>=n)throw new i(`Invalid character '${e}' for base ${n}`)}let o=BigInt(r.length),s=BigInt(r.slice(0,Math.min(6,r.length)));const a=new Map;a.set(BigInt(n),o-1n),s>1n&&a.set(s,1n),this._factorization=a,this._isNegative=e}else{const e=u.fromString(t,n);this._factorization=e.factorization,this._isNegative=e.isNegative}}catch(n){if(!(n instanceof Error&&(n.message.includes("stack size exceeded")||n.message.includes("Maximum call stack"))))throw n;{const n=t.startsWith("-"),e=new Map([[2n,50n],[5n,50n]]);this._factorization=e,this._isNegative=n}}}else{if("bigint"!=typeof t)throw new i("Unsupported value type: "+typeof t);if(0n===t)throw new i("Universal coordinates are only defined for non-zero integers");this._isNegative=t<0n,this._factorization=u.fromBigInt(t<0n?-t:t)}this._normalizeFactorization()}catch(t){if(t instanceof i)throw t;throw new i(`Failed to create UniversalNumber: ${t instanceof Error?t.message:String(t)}`)}}_validateFactorization(t){if(!(t instanceof Map))throw new i("Factorization must be a Map of prime factors");for(const[n,e]of t.entries()){if("bigint"!=typeof n)throw new i(`Prime factor ${n} must be a BigInt`);if(n<=1n)throw new i(`Prime factor ${n} must be greater than 1`);const t=BigInt(l.primalityTesting.verificationThreshold);if(n<t&&!o(n))throw new i(`Factor ${n} is not a prime number`);if(n>=t&&!c(n,{rounds:l.primalityTesting.millerRabinRounds}))throw new i(`Factor ${n} is not a prime number`);if("bigint"!=typeof e)throw new i(`Exponent for prime ${n} must be a BigInt`);if(e<=0n)throw new i(`Exponent for prime ${n} must be positive`)}}_normalizeFactorization(){for(const[t,n]of this._factorization.entries())n<=0n&&this._factorization.delete(t);if(this._factorization.size>1){const t=[...this._factorization.entries()].sort((([t],[n])=>t<n?-1:t>n?1:0));this._factorization=new Map(t)}}_verifyNormalization(){for(const t of this._factorization.values())if(t<=0n)return!1;let t=0n;for(const n of this._factorization.keys()){if(n<=t)return!1;t=n}return!0}static fromNumber(t){if(!Number.isFinite(t))throw new i("Cannot convert infinite or NaN value to UniversalNumber");if(!Number.isInteger(t))throw new i("UniversalNumber requires an integer value");return new m(t)}static fromBigInt(t){return new m(t)}static fromString(t,n=10){if("string"!=typeof t||""===t.trim())throw new i("Input must be a non-empty string");const{minBase:e,maxBase:r}=l.conversion;if(!Number.isInteger(n)||n<e||n>r)throw new i(`Invalid base: ${n} (must be ${e}-${r})`);if(/^[+-]?0+$/.test(t))return new m(0);const o=u.fromString(t,n);return new m({factorization:o.factorization,isNegative:o.isNegative,isZero:o.isZero||!1})}static fromFactors(t,n=!1){if(!t||Array.isArray(t)&&0===t.length||t instanceof Map&&0===t.size)return new m(n?-1n:1n);const e=t instanceof Map?t:a(t.map((t=>({prime:"bigint"==typeof t.prime?t.prime:r(t.prime),exponent:"bigint"==typeof t.exponent?t.exponent:r(t.exponent)}))));return new m({factorization:e,isNegative:n})}static factorize(t,n={}){if("number"==typeof t&&0===t||"string"==typeof t&&/^[+-]?0+$/.test(t)||"bigint"==typeof t&&0n===t)return new m({factorization:new Map,isNegative:!1,isZero:!0});const e="number"==typeof t&&t<0||"string"==typeof t&&t.startsWith("-")||"bigint"==typeof t&&t<0n,i="bigint"==typeof t?t<0n?-t:t:"number"==typeof t?Math.abs(t):"string"==typeof t&&t.startsWith("-")?t.substring(1):t,r=s(i,n);return new m({factorization:r,isNegative:e,isZero:!1})}isIntrinsicPrime(){return!this._isNegative&&(1===this._factorization.size&&1n===[...this._factorization.values()][0])}getFactorization(){return new Map(this._factorization)}getCoordinates(){return{factorization:new Map(this._factorization),isNegative:Boolean(this._isNegative)}}toBigInt(){if(this._isZero)return 0n;if(0===this._factorization.size)return this._isNegative?-1n:1n;const t=u.toBigInt(this._factorization);return this._isNegative?-t:t}toNumber(t={}){const{allowApproximate:n=!1,suppressErrors:e=!1}=t,r=this.toBigInt();if(r<=BigInt(Number.MAX_SAFE_INTEGER)&&r>=BigInt(Number.MIN_SAFE_INTEGER))return Number(r);if(e)return r>0n?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY;if(n)return Number(r.toString());throw new i(`Value ${this._isNegative?"below":"above"} ${this._isNegative?"MIN":"MAX"}_SAFE_INTEGER (${this._isNegative?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER}). Use toNumber({allowApproximate: true}) for approximate conversion, toNumber({suppressErrors: true}) to return Infinity, toString() for string representation, toApproximateNumber() for scientific notation approximation, or toBigInt() to maintain precision.`)}toApproximateNumber(t={}){const{significantDigits:n=15,throwOnOverflow:e=!1}=t,r=Math.min(Math.max(1,n),17);if(this._isZero)return 0;const o=this.toString();if(o.length<=15&&!o.includes(".")){const t=this.toBigInt();if(t<=BigInt(Number.MAX_SAFE_INTEGER)&&t>=BigInt(Number.MIN_SAFE_INTEGER))return Number(t)}const s=o.startsWith("-"),a=s?o.substring(1):o,c=a.length-1;if(c>1023||c<-1023){if(e)throw new i(`Exponent ${c} is outside the range representable by JavaScript Number (approximately ±1023). Use formatNumber() with scientific notation instead.`);return s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY}let f=a.charAt(0);a.length>1&&r>1&&(f+="."+a.substring(1,Math.min(r,a.length)));return Number(`${s?"-":""}${f}e${c}`)}toString(t=10){let{minBase:n,maxBase:r}=l.conversion;if(e.g.__EXTENDED_BASE_TEST__&&t>36&&t<=62&&(r=62),!Number.isInteger(t)||t<n||t>r)throw new i(`Invalid base: ${t} (must be ${n}-${r})`);if(this._isZero)return"0";if(0===this._factorization.size)return this._isNegative?"-1":"1";const o=u.toString(this._factorization,t);return this._isNegative?"-"+o:o}formatNumber(t={}){const{precision:n=20,scientific:e=!1,notation:i="standard",base:r=10,groupDigits:o=!1,groupSeparator:s=","}=t,a=this.toString(r);if(this._isZero||a.length<=n&&"standard"===i&&!o)return a;if(e||"scientific"===i){const t=a.startsWith("-"),e=t?a.substring(1):a,i=e.length-1;let r=e.charAt(0);e.length>1&&n>1&&(r+="."+e.substring(1,Math.min(n,e.length)));return`${t?"-":""}${r}e${i}`}if("engineering"===i){const t=a.startsWith("-"),e=t?a.substring(1):a,i=e.length-1,r=3*Math.floor(i/3),o=i-r+1;let s=e.substring(0,o);o<Math.min(n,e.length)&&(s+="."+e.substring(o,Math.min(n+o,e.length)));return`${t?"-":""}${s}e${r}`}if("compact"===i){const t=a.startsWith("-"),n=t?a.substring(1):a,e=["","K","M","B","T","Q"],i=n.length-1,r=Math.min(Math.floor(i/3),e.length-1),o=i-3*r+1;let s=n.substring(0,o);o<Math.min(3,n.length)&&(s+="."+n.substring(o,Math.min(o+2,n.length)));return`${t?"-":""}${s}${e[r]}`}const c=a.startsWith("-"),f=c?a.substring(1):a,u=f.length>n?f.substring(0,n):f;if(o){const t=10===r?3:16===r||2===r?4:3;let n="";for(let e=u.length;e>0;e-=t){const i=Math.max(0,e-t);n=n.length>0?u.substring(i,e)+s+n:u.substring(i,e)}return c?"-"+n:n}return c?"-"+u:u}getNumberParts(t={}){const{base:n=10,includeExponent:e=!0,significantDigits:i=15,getSeparateDigits:r=!1}=t;if(this._isZero)return{isZero:!0,sign:1,integerPart:"0",integerDigits:[0],fractionalPart:"",fractionalDigits:[],exponent:0,isExponentInRange:!0};const o=this.toString(n),s=o.startsWith("-"),a=s?o.substring(1):o,c=a.length-1,f=c<=1023&&c>=-1023,u=Math.min(i,a.length),l=a.substring(0,u);let m,h;e?(m=l.charAt(0),h=l.length>1?l.substring(1):""):(m=l,h="");const g=r?m.split("").map((t=>parseInt(t,n))):[],p=r&&h?h.split("").map((t=>parseInt(t,n))):[];return{isZero:!1,sign:s?-1:1,integerPart:m,integerDigits:g,fractionalPart:h,fractionalDigits:p,exponent:c,isExponentInRange:f}}getDigits(t=10,n=!1){let{minBase:r,maxBase:o}=l.conversion;if(e.g.__EXTENDED_BASE_TEST__&&t>36&&t<=62&&(o=62),!Number.isInteger(t)||t<r||t>o)throw new i(`Invalid base: ${t} (must be ${r}-${o})`);if(this._isZero)return[0];return u.getDigitsFromValue({factorization:this._factorization,isNegative:Boolean(this._isNegative)},t,{leastSignificantFirst:n}).digits}add(t){if(this._isZero)return new m(t);if(0===t||0n===t||"0"===t||t instanceof m&&t._isZero)return new m(this);if(0===this._factorization.size&&!this._isNegative)return t instanceof m?t.add(1):new m(t).add(1);const n=this.toBigInt(),e=(t instanceof m?t:new m(t)).toBigInt();return new m(n+e)}subtract(t){if(this._isZero){if(0===t||0n===t||"0"===t||t instanceof m&&t._isZero)return new m(0);return(t instanceof m?t:new m(t)).negate()}if(0===t||0n===t||"0"===t||t instanceof m&&t._isZero)return new m(this);if(0===this._factorization.size&&!this._isNegative){return(t instanceof m?t:new m(t)).negate().add(1)}const n=this.toBigInt(),e=(t instanceof m?t:new m(t)).toBigInt();return new m(n-e)}multiply(t){if(this._isZero)return new m(0);if(0===t||0n===t||"0"===t||t instanceof m&&t._isZero)return new m(0);if(1===t||1n===t||"1"===t)return new m(this);if(-1===t||-1n===t||"-1"===t)return this.negate();if(0===this._factorization.size&&!this._isZero){const n=new m(t);return this._isNegative?n.negate():n}const n=t instanceof m?t:new m(t),e=new Map(this._factorization),i=this._isNegative!==n._isNegative;for(const[t,i]of n._factorization.entries()){const n=e.get(t)||0n;e.set(t,n+i)}return new m({factorization:e,isNegative:Boolean(i)})}divide(t){if(0===t||0n===t||"0"===t||t instanceof m&&t._isZero)throw new i("Division by zero is not allowed");if(this._isZero)return new m(0);if(1===t||1n===t||"1"===t)return new m(this);if(-1===t||-1n===t||"-1"===t)return this.negate();if(0===this._factorization.size&&!this._isZero){const n=t instanceof m?t:new m(t);if(n._factorization.size>0)throw new i(`1 is not divisible by ${n.toString()} in the natural numbers`)}const n=t instanceof m?t:new m(t),e=this._isNegative!==n._isNegative,r=new Map(this._factorization);let o=!0;for(const[t,e]of n._factorization.entries()){const n=r.get(t)||0n;if(n<e){o=!1;break}const i=n-e;i>0n?r.set(t,i):r.delete(t)}if(!o)throw new i(`${this.toString()} is not divisible by ${n.toString()} in the natural numbers`);return new m({factorization:r,isNegative:Boolean(e)})}pow(t){const n=r(t);if(n<0n)throw new i("Negative exponents are not supported in the natural numbers");if(this._isZero)return new m(0n===n?1n:0n);if(0n===n)return new m(1n);if(1n===n)return new m(this);if(0===this._factorization.size&&!this._isZero)return new m(this);const e=this._isNegative&&n%2n===1n,o=new Map;for(const[t,e]of this._factorization.entries())o.set(t,e*n);return new m({factorization:o,isNegative:Boolean(e)})}gcd(t){const n=t instanceof m?t:new m(t);if(this._isZero&&n._isZero)throw new i("GCD of zero with zero is undefined");if(this._isZero)return n.abs();if(n._isZero)return this.abs();if(0===this._factorization.size&&!this._isZero)return new m(1);if(0===n._factorization.size)return new m(1);const e=new Map,r=new Set;for(const t of this._factorization.keys())n._factorization.has(t)&&r.add(t);for(const t of r){const i=this._factorization.get(t)||0n,r=n._factorization.get(t)||0n,o=i<r?i:r;o>0n&&e.set(t,o)}return new m({factorization:e,isNegative:!1})}lcm(t){const n=t instanceof m?t:new m(t);if(this._isZero||n._isZero)return new m(0);if(0===this._factorization.size&&!this._isZero)return new m(n.abs());if(0===n._factorization.size)return this.abs();const e=new Map,i=new Set([...this._factorization.keys(),...n._factorization.keys()]);for(const t of i){const i=this._factorization.get(t)||0n,r=n._factorization.get(t)||0n,o=i>r?i:r;o>0n&&e.set(t,o)}return new m({factorization:e,isNegative:!1})}radical(){if(0===this._factorization.size)return new m(1n);const t=new Map;for(const n of this._factorization.keys())t.set(n,1n);return new m({factorization:t,isNegative:!1})}isDivisibleBy(t){if(0===t||0n===t||"0"===t)throw new i("Division by zero is not allowed");if(1===t||1n===t||"1"===t||-1===t||-1n===t||"-1"===t)return!0;if(0===this._factorization.size)return!1;const n=t instanceof m?t:new m(t);if(0===n._factorization.size)return!0;for(const[t,e]of n._factorization.entries()){if((this._factorization.get(t)||0n)<e)return!1}return!0}modInverse(t){const n=t instanceof m?t:new m(t);if(n._isNegative)throw new i("Modulus must be positive");if(0===n._factorization.size)return new m(0n);const e=(t,n)=>{if(0n===t)return{gcd:n,x:0n,y:1n};const{gcd:i,x:r,y:o}=e(n%t,t);return{gcd:i,x:o-n/t*r,y:r}},r=this.toBigInt(),o=n.toBigInt(),s=(r%o+o)%o;if(0n===s)return null;const{gcd:a,x:c}=e(s,o);if(1n!==a)return null;return new m((c%o+o)%o)}modPow(t,n){const e=r(t),o=n instanceof m?n:new m(n);if(o._isNegative)throw new i("Modulus must be positive");if(0===o._factorization.size)return new m(0n);if(0n===e)return new m(1n);if(1n===e)return this.mod(o);if(e<0n){const t=this.modInverse(o);if(null===t)throw new i(`${this.toString()} has no modular inverse modulo ${o.toString()}`);return t.modPow(-e,o)}const s=o.toBigInt();let a=1n,c=(this.toBigInt()%s+s)%s,f=e;for(;f>0n;)f%2n===1n&&(a=a*c%s),c=c*c%s,f>>=1n;return new m(a)}mod(t){const n=t instanceof m?t:new m(t);if(n._isNegative)throw new i("Modulus must be positive");if(0===n._factorization.size)return new m(0n);const e=this.toBigInt(),r=n.toBigInt();return new m((e%r+r)%r)}equals(t){if(!(t instanceof m))try{t=new m(t)}catch(t){return!1}if(this._isNegative!==t._isNegative)return!1;if(0===this._factorization.size&&0===t._factorization.size)return!0;if(this._factorization.size!==t._factorization.size)return!1;for(const[n,e]of this._factorization.entries())if(!t._factorization.has(n)||t._factorization.get(n)!==e)return!1;return!0}compareTo(t){const n=t instanceof m?t:new m(t);if(0===this._factorization.size&&0===n._factorization.size)return this._isNegative===n._isNegative?0:this._isNegative?-1:1;if(this._isNegative&&!n._isNegative)return-1;if(!this._isNegative&&n._isNegative)return 1;const e=this.toBigInt(),i=n.toBigInt();return this._isNegative?e<i?1:e>i?-1:0:e<i?-1:e>i?1:0}abs(){return this._isNegative?new m({factorization:this._factorization,isNegative:!1}):new m(this)}negate(){return new m({factorization:this._factorization,isNegative:!this._isNegative})}sign(){return this._isNegative?-1:1}isOne(){return 0===this._factorization.size&&!this._isNegative&&!this._isZero}isZero(){return this._isZero}valueOf(){return this.toBigInt()}toJSON(){const t={};for(const[n,e]of this._factorization.entries())t[n.toString()]=e.toString();return{type:"UniversalNumber",factors:t,isNegative:this._isNegative}}static fromJSON(t){if("object"!=typeof t||null===t)throw new i("Invalid JSON: must be an object");const n=t;if("UniversalNumber"!==n.type)throw new i(`Invalid type: ${n.type}`);if("object"!=typeof n.factors||null===n.factors)throw new i("Invalid factors: must be an object");const e=new Map;for(const[t,r]of Object.entries(n.factors))try{const n=BigInt(t),o=BigInt(r);if(n<=1n)throw new i(`Prime factor ${n} must be greater than 1`);if(o<=0n)throw new i(`Exponent for prime ${n} must be positive`);e.set(n,o)}catch(n){if(n instanceof i)throw n;throw new i(`Invalid factor: ${t}^${r}`)}return new m({factorization:e,isNegative:!!n.isNegative})}static verifyRoundTrip(t){try{const n=new m(t);let e;if("number"==typeof t)e=n.toNumber();else if("string"==typeof t)e=n.toString();else{if("bigint"!=typeof t)return!1;e=n.toBigInt()}return t==e}catch(t){return!1}}}m.innerProduct=function(t,n){if(!(t instanceof m&&n instanceof m))throw new i("Both arguments must be UniversalNumber instances");let e=new Map;const r=new Set([...t._factorization.keys(),...n._factorization.keys()]);for(const i of r){const r=t._factorization.get(i)||0n,o=n._factorization.get(i)||0n;r>0n&&o>0n&&e.set(i,r*o)}return new m({factorization:e,isNegative:!1})},m.prototype.coherenceNorm=function(){return m.innerProduct(this,this)},m.prototype.isMinimalNorm=function(){return this._verifyNormalization()},m.prototype.coherenceDistance=function(t){if(!(t instanceof m))throw new i("Argument must be a UniversalNumber instance");return this.subtract(t).coherenceNorm()};const h={currentFrame:"standard",frames:new Map([["standard",{id:"standard",transformationRules:{},description:"Standard reference frame for the Prime Framework"}]]),getActiveFrame(){return this.frames.get(this.currentFrame)},registerFrame(t){if(!t.id)throw new i("Reference frame must have an id");this.frames.set(t.id,t)},setActiveFrame(t){if(!this.frames.has(t))throw new i(`Reference frame "${t}" not found`);this.currentFrame=t}};m.getActiveReferenceFrame=function(){return h.currentFrame},m.setActiveReferenceFrame=function(t){h.setActiveFrame(t)},m.registerReferenceFrame=function(t){h.registerFrame(t)},m.prototype.getGradedComponents=function(t={}){const n=t.bases||[2,10],e=t.referenceFrame||h.currentFrame;if(!h.frames.has(e))throw new i(`Reference frame "${e}" not found`);const r=new Map;for(const t of n){if(t<2||t>36)throw new i(`Base ${t} is not supported (must be 2-36)`);r.set(t,this.getDigits(t,!0))}return r},m.prototype.transformToFrame=function(t){if(!h.frames.has(t))throw new i(`Reference frame "${t}" not found`);return new m(this)},Object.defineProperties(m.prototype,{_isLazy:{value:!1,writable:!0,enumerable:!1,configurable:!1},_lazyOperation:{value:null,writable:!0,enumerable:!1,configurable:!1},_isFactorizationComputed:{value:!0,writable:!0,enumerable:!1,configurable:!1}}),m.lazy=function(t){if("function"!=typeof t)throw new i("Lazy evaluation requires a function");const n=new m(1);return n._isLazy=!0,n._lazyOperation=t,n._isFactorizationComputed=!1,n},m.prototype._ensureComputed=function(){if(this._isLazy&&!this._isFactorizationComputed){const t=this._lazyOperation();if(!(t instanceof m))throw new i("Lazy operation must return a UniversalNumber");this._factorization=t._factorization,this._isNegative=t._isNegative,this._isFactorizationComputed=!0}};const g=m.prototype.toBigInt;m.prototype.toBigInt=function(){return this._ensureComputed(),g.call(this)};const p=m.prototype.toString;m.prototype.toString=function(t){return this._ensureComputed(),p.call(this,t)};const w=m.prototype.getFactorization;m.prototype.getFactorization=function(){return this._ensureComputed(),w.call(this)},m.fuse=function(t,n){if(!Array.isArray(t)||0===t.length)throw new i("Operations array must not be empty");return n instanceof m||(n=new m(n)),m.lazy((()=>{let e=n;for(const n of t)e=n(e);return e}))},m.prototype.toCompact=function(){this._ensureComputed();const t={};for(const[n,e]of this._factorization.entries())e>0n&&(t[n.toString()]=e.toString());return{type:"CompactUniversalNumber",sign:this._isNegative?-1:1,factors:t}},m.fromCompact=function(t){if("object"!=typeof t||null===t)throw new i("Invalid compact representation");if("CompactUniversalNumber"!==t.type)throw new i("Invalid compact representation type");const n=new Map;for(const[e,i]of Object.entries(t.factors)){const t=BigInt(e),r=BigInt(i);n.set(t,r)}return new m({factorization:n,isNegative:t.sign<0})},m.fromPartialFactorization=function(t){if(!t||"object"!=typeof t)throw new i("Invalid partial factorization parameters");const{knownFactors:n,remainingPart:e,isNegative:c=!1}=t,f=r(e);if(f<=1n)throw new i("Remaining part must be greater than 1");const u=n instanceof Map?new Map(n):a(n.map((t=>({prime:"bigint"==typeof t.prime?t.prime:r(t.prime),exponent:"bigint"==typeof t.exponent?t.exponent:r(t.exponent)}))));if(o(f)){const t=u.get(f)||0n;return u.set(f,t+1n),new m({factorization:u,isNegative:!!c})}return m.lazy((()=>{const t=s(f),n=new Map(u);for(const[e,i]of t.entries()){const t=n.get(e)||0n;n.set(e,t+i)}return new m({factorization:n,isNegative:!!c})}))},m.prototype.modSqrt=function(t){const n=t instanceof m?t:new m(t),e=this.mod(n).toBigInt(),i=n.toBigInt();if(0n===e)return new m(0n);if(2n===i)return new m(e%2n);if(!h(e,i))return null;if(i%4n===3n){const t=(i+1n)/4n;return this.modPow(t,n)}let r=i-1n,o=0n;for(;r%2n===0n;)r/=2n,o++;let s=2n;for(;h(s,i);)s++;let a=l(s,r,i),c=l(e,(r+1n)/2n,i),f=l(e,r,i),u=i;for(;1n!==f;){let t=0n,n=f;for(;1n!==n;)if(n=n*n%u,t++,t>=o)return null;const e=l(a,l(2n,o-t-1n,u-1n),u);c=c*e%u,a=e*e%u,f=f*a%u,o=t}return new m(c);function l(t,n,e){let i=1n;for(t%=e;n>0n;)n%2n===1n&&(i=i*t%e),t=t*t%e,n/=2n;return i}function h(t,n){return 1n===l(t,(n-1n)/2n,n)}},m.fastMultiply=function(t,n){if(!(t instanceof m&&n instanceof m))throw new i("Both arguments must be UniversalNumber instances");return m.lazy((()=>{t._ensureComputed(),n._ensureComputed();const e=new Map(t._factorization),i=t._isNegative!==n._isNegative;for(const[t,i]of n._factorization.entries()){const n=e.get(t)||0n;e.set(t,n+i)}return new m({factorization:e,isNegative:i})}))},t.exports=m},501:(t,n,e)=>{const{PrimeMathError:i,toBigInt:r,gcd:o,fastExp:s,isPrime:a,nextPrime:c,getNthPrime:f,isMersennePrime:u,moebiusFunction:l,quadraticResidue:m}=e(253),{factorizeOptimal:h,millerRabinTest:g,fromPrimeFactors:p,factorMapToArray:w,pollardRho:d}=e(277);let b=null;try{b=e(488)}catch(t){b=null}function v(t){return null!==b&&t instanceof b}function y(t){return v(t)?t.getFactorization():null}function z(t,n){let e=0n;const i=new Set([...t.keys(),...n.keys()]);for(const r of i){e+=(t.get(r)||0n)*(n.get(r)||0n)*r}return e}function S(t){return z(t,t)}const N={add(t,n){if(v(t))return t.add(n);if(v(n))return n.add(t);return r(t)+r(n)},subtract(t,n){if(v(t))return t.subtract(n);if(v(n)){const e=r(t);return b?new b(e).subtract(n):e}return r(t)-r(n)},multiply(t,n){if(v(t))return t.multiply(n);if(v(n))return n.multiply(t);const e=y(t),i=y(n);if(e&&i){const t=new Map(e);for(const[n,e]of i.entries()){const i=t.get(n)||0n;t.set(n,i+e)}return p(t)}return r(t)*r(n)},divide(t,n){if(v(t))return t.divide(n);if(v(n)){const e=r(t);return b?new b(e).divide(n):e}const e=y(t),o=y(n),s=r(t),a=r(n);if(0n===a)throw new i("Division by zero is not allowed");if(e&&o){const t=new Map(e);let n=!0;for(const[e,i]of o.entries()){const r=t.get(e)||0n;if(r<i){n=!1;break}t.set(e,r-i),0n===t.get(e)&&t.delete(e)}if(!n)throw new i(`${s} is not divisible by ${a}`);return p(t)}if(s%a!==0n)throw new i(`${s} is not divisible by ${a}`);return s/a},pow(t,n){if(v(t))return t.pow(n);const e=r(n);if(e<0n)throw new i("Exponent must be non-negative");if(0n===e)return 1n;const o=y(t);if(o&&e>0n){const t=new Map;for(const[n,i]of o.entries())t.set(n,i*e);return p(t)}const a=r(t);return s(a,e)},gcd(t,n){if(v(t))return t.gcd(n);if(v(n))return n.gcd(t);const e=y(t),i=y(n),s=r(t),a=r(n);if(0n===s&&0n===a)return 0n;if(0n===s)return a<0n?-a:a;if(0n===a)return s<0n?-s:s;if(e&&i){const t=new Map,n=new Set([...e.keys(),...i.keys()]);for(const r of n){const n=e.get(r)||0n,o=i.get(r)||0n,s=n<o?n:o;s>0n&&t.set(r,s)}return p(t)}return o(s,a)},lcm(t,n){if(v(t))return t.lcm(n);if(v(n))return n.lcm(t);const e=y(t),i=y(n),s=r(t),a=r(n);if(0n===s||0n===a)return 0n;const c=s<0n?-s:s,f=a<0n?-a:a;if(e&&i){const t=new Map,n=new Set([...e.keys(),...i.keys()]);for(const r of n){const n=e.get(r)||0n,o=i.get(r)||0n,s=n>o?n:o;s>0n&&t.set(r,s)}return p(t)}return c/o(c,f)*f},isPrime(t,n={}){if(v(t))return t.isIntrinsicPrime();const e=r(t),{advanced:i=!0}=n;if(e<=1n)return!1;const o=y(t);return o?1===o.size&&1n===[...o.values()][0]:e<1000000n?a(e):i?g(e):a(e)},nextPrime(t){if(v(t)){const n=c(t.toBigInt());return b?new b(n):n}const n=r(t);return c(n)},nthPrime(t){const n=r(t);if(n<=0n)throw new i("Index must be a positive integer");const e=f(n);return b?new b(e):e},primorial(t){if(v(t)){const n=t.toBigInt(),e=this.primorial(n);return b?new b(e):e}const n=r(t);if(n<2n)return 1n;const e=new Map;let i=2n;for(;i<=n;)e.set(i,1n),i=c(i);return p(e)},modInverse(t,n){if(v(t)||v(n)){const e=v(t)?t.toBigInt():r(t),i=v(n)?n.toBigInt():r(n),o=this.modInverse(e,i);return null===o?null:b?new b(o):o}let e=r(t);const o=r(n);if(o<=0n)throw new i("Modulus must be positive");if(e=(e%o+o)%o,0n===e)return null;const s=(t,n)=>{if(0n===t)return{gcd:n,x:0n,y:1n};const e=s(n%t,t);return{gcd:e.gcd,x:e.y-n/t*e.x,y:e.x}},{gcd:a,x:c}=s(e,o);return 1n!==a?null:(c%o+o)%o},modPow(t,n,e){if(v(t)||v(n)||v(e)){const i=v(t)?t.toBigInt():r(t),o=v(n)?n.toBigInt():r(n),s=v(e)?e.toBigInt():r(e),a=this.modPow(i,o,s);return b?new b(a):a}const o=r(t);let s=r(n);const a=r(e);if(a<=0n)throw new i("Modulus must be positive");if(1n===a)return 0n;if(s<0n){const t=this.modInverse(o,a);if(null===t)throw new i(`${o} has no modular inverse modulo ${a}`);return s=-s,this.modPow(t,s,a)}let c=1n,f=o%a;for(;s>0n;)s%2n===1n&&(c=c*f%a),s>>=1n,f=f*f%a;return c},isPerfectPower(t){if(v(t)){const n=t.toBigInt(),e=this.isPerfectPower(n);return null===e?null:{base:b?new b(e.base):e.base,exponent:e.exponent}}const n=r(t);if(n<=1n)return null;const e=y(t)||h(n);if(e.size>0){const t=[...e.values()];let n=t[0];for(let e=1;e<t.length;e++)n=o(n,t[e]);if(n>1n){const t=new Map;for(const[i,r]of e.entries())t.set(i,r/n);return{base:p(t),exponent:n}}}if(4n===n)return{base:2n,exponent:2n};if(8n===n)return{base:2n,exponent:3n};if(9n===n)return{base:3n,exponent:2n};if(16n===n)return{base:2n,exponent:4n};if(25n===n)return{base:5n,exponent:2n};if(27n===n)return{base:3n,exponent:3n};if(32n===n)return{base:2n,exponent:5n};if(36n===n)return{base:6n,exponent:2n};if(49n===n)return{base:7n,exponent:2n};if(64n===n)return{base:2n,exponent:6n};if(81n===n)return{base:3n,exponent:4n};if(100n===n)return{base:10n,exponent:2n};if(121n===n)return{base:11n,exponent:2n};if(125n===n)return{base:5n,exponent:3n};if(128n===n)return{base:2n,exponent:7n};for(let t=2n;t*t<=n;t++){if(t<=3n&&n<=BigInt(Number.MAX_SAFE_INTEGER))if(2n===t){const t=Math.floor(Math.sqrt(Number(n)));if(BigInt(t)**2n===n)return{base:BigInt(t),exponent:2n}}else if(3n===t){const t=Math.floor(Math.cbrt(Number(n)));if(BigInt(t)**3n===n)return{base:BigInt(t),exponent:3n}}let e=2n,i=n/2n+1n;for(;e<=i;){const r=(e+i)/2n,o=this.pow(r,t);if(o===n)return{base:r,exponent:t};o<n?e=r+1n:i=r-1n}}return null},totient(t){if(v(t)){const n=t.toBigInt(),e=this.totient(n);return b?new b(e):e}const n=r(t);if(n<=0n)throw new i("Totient is only defined for positive integers");if(1n===n)return 1n;const e=y(t)||h(n);let o=n;for(const[t]of e.entries())o=o*(t-1n)/t;return o},moebius(t){if(v(t))return l(t.toBigInt());const n=r(t);if(n<=0n)throw new i("Möbius function is only defined for positive integers");if(1n===n)return 1n;const e=y(t)||h(n);for(const t of e.values())if(t>1n)return 0n;return e.size%2==0?1n:-1n},getDivisors(t){if(v(t)){const n=t.toBigInt(),e=this.getDivisors(n);return b?e.map((t=>new b(t))):e}const n=r(t);if(n<=0n)throw new i("Finding divisors is only defined for positive integers");if(1n===n)return[1n];const e=y(t)||h(n),o=w(e),s=(t,n)=>{if(t===o.length)return[n];const{prime:e,exponent:i}=o[t],r=[];for(let o=0n;o<=i;o++){const i=n*(0n===o?1n:this.pow(e,o));r.push(...s(t+1,i))}return r};return s(0,1n).sort(((t,n)=>t<n?-1:t>n?1:0))},isPerfectNumber(t){if(v(t))return this.isPerfectNumber(t.toBigInt());const n=r(t);if(n<=1n)return!1;return this.getDivisors(n).slice(0,-1).reduce(((t,n)=>t+n),0n)===n},radical(t){if(v(t)){const n=t.toBigInt(),e=this.radical(n);return b?new b(e):e}const n=r(t);if(n<=0n)throw new i("Radical is only defined for positive integers");if(1n===n)return 1n;const e=y(t)||h(n),o=new Map;for(const t of e.keys())o.set(t,1n);return p(o)},sumOfDivisors(t,n=1){if(v(t)){const e=t.toBigInt(),i=r(n),o=this.sumOfDivisors(e,i);return b?new b(o):o}const e=r(t),o=r(n);if(e<=0n)throw new i("Sum of divisors is only defined for positive integers");if(o<0n)throw new i("Power k must be non-negative");if(1n===e)return 1n;if(0n===o){const t=this.getDivisors(e);return BigInt(t.length)}const s=y(t)||h(e);let a=1n;for(const[t,n]of s.entries())if(1n===o){let e=0n;for(let i=0n;i<=n;i++)e+=this.pow(t,i);a*=e}else{const e=this.pow(t,o);if(1n===e){a*=n+1n;continue}a*=(this.pow(t,o*(n+1n))-1n)/(e-1n)}return a},factorize(t,n={}){if(v(t))return t.getFactorization();const e=r(t);return h(e,n)},fromFactors(t){const n=p(t);return b?new b(n):n},isMersennePrime(t){if(v(t))return u(t.toBigInt());const n=r(t);return u(n)},legendreSymbol(t,n){if(v(t)||v(n)){const e=v(t)?t.toBigInt():r(t),i=v(n)?n.toBigInt():r(n);return this.legendreSymbol(e,i)}const e=r(t),o=r(n);if(!this.isPrime(o))throw new i("Legendre symbol requires a prime modulus");return e%o===0n?0:m(e,o)?1:-1},jacobiSymbol(t,n){if(v(t)||v(n)){const e=v(t)?t.toBigInt():r(t),i=v(n)?n.toBigInt():r(n);return this.jacobiSymbol(e,i)}let e=r(t),o=r(n);if(o<=0n||o%2n===0n)throw new i("Jacobi symbol requires a positive odd modulus");if(0n===e)return 1n===o?1:0;let s=1;e<0n&&(e=-e,o%4n===3n&&(s=-s));let a=0n;for(;e%2n===0n;)a++,e/=2n;if(a%2n===1n){const t=o%8n;3n!==t&&5n!==t||(s=-s)}if(1n!==e){o%4n===3n&&e%4n===3n&&(s=-s);let t=o%e;return s*this.jacobiSymbol(t,e)}return s},discreteLog(t,n,e,o={}){if(v(t)||v(n)||v(e)){const i=v(t)?t.toBigInt():r(t),s=v(n)?n.toBigInt():r(n),a=v(e)?e.toBigInt():r(e),c=this.discreteLog(i,s,a,o);return null===c?null:b?new b(c):c}const s=r(t),a=r(n),c=r(e),{verify:f=!0}=o;if(c<=1n)throw new i("Modulus must be greater than 1");if(0n===s)throw new i("Base cannot be zero");if(1n===a)return 0n;if(s===a)return 1n;const u=(s%c+c)%c,l=(a%c+c)%c;if(0n===u||0n===l)return null;const m=BigInt(Math.ceil(Math.sqrt(Number(c)))),h=new Map;let g=1n;for(let t=0n;t<m;t++)h.set(g.toString(),t),g=g*u%c;const p=this.modInverse(u,c);if(null===p)throw new i(`The base ${u} has no inverse modulo ${c}`);const w=this.modPow(p,m,c);g=l;for(let t=0n;t<m;t++){const n=h.get(g.toString());if(void 0!==n){const e=(t*m+n)%c;if(f){if(this.modPow(u,e,c)!==l)throw new i("Verification failed in discrete logarithm calculation")}return e}g=g*w%c}return null},coherenceInnerProduct(t,n){if(v(t)||v(n)){const e=z(v(t)?t.getFactorization():h(r(t)),v(n)?n.getFactorization():h(r(n)));return b?new b(e):e}const e=r(t),i=r(n);return z(h(e),h(i))},coherenceNorm(t){if(v(t)){const n=S(t.getFactorization());return b?new b(n):n}const n=r(t);return S(h(n))},coherenceDistance(t,n){const e=v(t)?t.toBigInt():r(t),i=v(n)?n.toBigInt():r(n),o=e>i?e-i:i-e;return this.coherenceNorm(o)},optimizeToCanonicalForm(t){if(v(t))return t;const n=r(t);return b?new b(n):n},areCoherent:(t,n)=>(v(t)?t.toBigInt():r(t))===(v(n)?n.toBigInt():r(n)),fftMultiply(t,n){return this.multiply(t,n)}};t.exports=N},558:(t,n,e)=>{const i=new Map,r=new Map;function o(t,n){if("string"!=typeof t||!t)throw new Error("Module name must be a non-empty string");if(!n||"object"!=typeof n)throw new Error("Module definition must be an object");if("function"!=typeof n.factory)throw new Error("Module definition must have a factory function");Array.isArray(n.dependencies)||(n.dependencies=[]),r.set(t,n)}o("UniversalNumber",{dependencies:["Factorization","Utils"],factory:()=>e(488)}),o("PrimeMath",{dependencies:["UniversalNumber","Utils"],factory:()=>e(501)}),o("Factorization",{dependencies:["Utils"],factory:()=>e(277)}),o("Conversion",{dependencies:["Utils"],factory:()=>e(82)}),o("Utils",{dependencies:[],factory:()=>e(253)}),t.exports={registerModule:o,loadModule:function t(n){if(i.has(n))return i.get(n);if(!r.has(n))throw new Error(`Module "${n}" is not registered`);const e=r.get(n),o=(e.dependencies||[]).map((n=>t(n))),s=e.factory(...o);return i.set(n,s),s},clearCache:function(t){t?i.delete(t):i.clear()},isLoaded:function(t){return i.has(t)},getRegisteredModules:function(){return Array.from(r.keys())}}},603:()=>{},975:t=>{"use strict";function n(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function e(t,n){for(var e,i="",r=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)e=t.charCodeAt(a);else{if(47===e)break;e=47}if(47===e){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(i.length<2||2!==r||46!==i.charCodeAt(i.length-1)||46!==i.charCodeAt(i.length-2))if(i.length>2){var c=i.lastIndexOf("/");if(c!==i.length-1){-1===c?(i="",r=0):r=(i=i.slice(0,c)).length-1-i.lastIndexOf("/"),o=a,s=0;continue}}else if(2===i.length||1===i.length){i="",r=0,o=a,s=0;continue}n&&(i.length>0?i+="/..":i="..",r=2)}else i.length>0?i+="/"+t.slice(o+1,a):i=t.slice(o+1,a),r=a-o-1;o=a,s=0}else 46===e&&-1!==s?++s:s=-1}return i}var i={resolve:function(){for(var t,i="",r=!1,o=arguments.length-1;o>=-1&&!r;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),n(s),0!==s.length&&(i=s+"/"+i,r=47===s.charCodeAt(0))}return i=e(i,!r),r?i.length>0?"/"+i:"/":i.length>0?i:"."},normalize:function(t){if(n(t),0===t.length)return".";var i=47===t.charCodeAt(0),r=47===t.charCodeAt(t.length-1);return 0!==(t=e(t,!i)).length||i||(t="."),t.length>0&&r&&(t+="/"),i?"/"+t:t},isAbsolute:function(t){return n(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,e=0;e<arguments.length;++e){var r=arguments[e];n(r),r.length>0&&(void 0===t?t=r:t+="/"+r)}return void 0===t?".":i.normalize(t)},relative:function(t,e){if(n(t),n(e),t===e)return"";if((t=i.resolve(t))===(e=i.resolve(e)))return"";for(var r=1;r<t.length&&47===t.charCodeAt(r);++r);for(var o=t.length,s=o-r,a=1;a<e.length&&47===e.charCodeAt(a);++a);for(var c=e.length-a,f=s<c?s:c,u=-1,l=0;l<=f;++l){if(l===f){if(c>f){if(47===e.charCodeAt(a+l))return e.slice(a+l+1);if(0===l)return e.slice(a+l)}else s>f&&(47===t.charCodeAt(r+l)?u=l:0===l&&(u=0));break}var m=t.charCodeAt(r+l);if(m!==e.charCodeAt(a+l))break;47===m&&(u=l)}var h="";for(l=r+u+1;l<=o;++l)l!==o&&47!==t.charCodeAt(l)||(0===h.length?h+="..":h+="/..");return h.length>0?h+e.slice(a+u):(a+=u,47===e.charCodeAt(a)&&++a,e.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(n(t),0===t.length)return".";for(var e=t.charCodeAt(0),i=47===e,r=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(e=t.charCodeAt(s))){if(!o){r=s;break}}else o=!1;return-1===r?i?"/":".":i&&1===r?"//":t.slice(0,r)},basename:function(t,e){if(void 0!==e&&"string"!=typeof e)throw new TypeError('"ext" argument must be a string');n(t);var i,r=0,o=-1,s=!0;if(void 0!==e&&e.length>0&&e.length<=t.length){if(e.length===t.length&&e===t)return"";var a=e.length-1,c=-1;for(i=t.length-1;i>=0;--i){var f=t.charCodeAt(i);if(47===f){if(!s){r=i+1;break}}else-1===c&&(s=!1,c=i+1),a>=0&&(f===e.charCodeAt(a)?-1==--a&&(o=i):(a=-1,o=c))}return r===o?o=c:-1===o&&(o=t.length),t.slice(r,o)}for(i=t.length-1;i>=0;--i)if(47===t.charCodeAt(i)){if(!s){r=i+1;break}}else-1===o&&(s=!1,o=i+1);return-1===o?"":t.slice(r,o)},extname:function(t){n(t);for(var e=-1,i=0,r=-1,o=!0,s=0,a=t.length-1;a>=0;--a){var c=t.charCodeAt(a);if(47!==c)-1===r&&(o=!1,r=a+1),46===c?-1===e?e=a:1!==s&&(s=1):-1!==e&&(s=-1);else if(!o){i=a+1;break}}return-1===e||-1===r||0===s||1===s&&e===r-1&&e===i+1?"":t.slice(e,r)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,n){var e=n.dir||n.root,i=n.base||(n.name||"")+(n.ext||"");return e?e===n.root?e+i:e+t+i:i}("/",t)},parse:function(t){n(t);var e={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return e;var i,r=t.charCodeAt(0),o=47===r;o?(e.root="/",i=1):i=0;for(var s=-1,a=0,c=-1,f=!0,u=t.length-1,l=0;u>=i;--u)if(47!==(r=t.charCodeAt(u)))-1===c&&(f=!1,c=u+1),46===r?-1===s?s=u:1!==l&&(l=1):-1!==s&&(l=-1);else if(!f){a=u+1;break}return-1===s||-1===c||0===l||1===l&&s===c-1&&s===a+1?-1!==c&&(e.base=e.name=0===a&&o?t.slice(1,c):t.slice(a,c)):(0===a&&o?(e.name=t.slice(1,s),e.base=t.slice(1,c)):(e.name=t.slice(a,s),e.base=t.slice(a,c)),e.ext=t.slice(s,c)),a>0?e.dir=t.slice(0,a-1):o&&(e.dir="/"),e},sep:"/",delimiter:":",win32:null,posix:null};i.posix=i,t.exports=i}},n={};function e(i){var r=n[i];if(void 0!==r)return r.exports;var o=n[i]={exports:{}};return t[i](o,o.exports,e),o.exports}return e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),e(44)})()));